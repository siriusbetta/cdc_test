
cdc_test.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000023cc  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80004400  80004400  00004800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000001b0  80004600  80004600  00004a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         0000009c  00000008  800047b0  00004c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  000000a4  8000484c  00004ca4  2**0
                  ALLOC
  8 .bss          00000520  000000c0  000000c0  00000000  2**5
                  ALLOC
  9 .heap         0000ea20  000005e0  000005e0  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00004ca4  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000aa0  00000000  00000000  00004cd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00001bbf  00000000  00000000  00005774  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0001f01d  00000000  00000000  00007333  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00002a47  00000000  00000000  00026350  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000ae5e  00000000  00000000  00028d97  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00001ac4  00000000  00000000  00033bf8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00007840  00000000  00000000  000356bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    000043f0  00000000  00000000  0003cefc  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 01716f97  00000000  00000000  000412ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00000af8  00000000  00000000  01758283  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	fe cf ee 1c 	sub	pc,pc,-4580

Disassembly of section .text:

80002004 <board_init>:
#if defined (CONF_BOARD_AT45DBX)
#define AT45DBX_MEM_CNT             1
#endif

void board_init(void)
{
80002004:	d4 01       	pushm	lr
		MREPEAT(AT45DBX_MEM_CNT, AT45DBX_ENABLE_NPCS_PIN, ~)
#  undef AT45DBX_ENABLE_NPCS_PIN
	};

	// Assign I/Os to SPI.
	gpio_enable_module(AT45DBX_SPI_GPIO_MAP,
80002006:	30 4b       	mov	r11,4
80002008:	49 4c       	lddpc	r12,80002058 <board_init+0x54>
8000200a:	f0 1f 00 15 	mcall	8000205c <board_init+0x58>
		{SD_MMC_SPI_MOSI_PIN, SD_MMC_SPI_MOSI_FUNCTION},
		{SD_MMC_SPI_NPCS_PIN, SD_MMC_SPI_NPCS_FUNCTION},
	};

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
8000200e:	30 4b       	mov	r11,4
80002010:	49 4c       	lddpc	r12,80002060 <board_init+0x5c>
80002012:	f0 1f 00 13 	mcall	8000205c <board_init+0x58>
			sizeof(SD_MMC_SPI_GPIO_MAP) / sizeof(SD_MMC_SPI_GPIO_MAP[0]));
#endif
	// Configure the pins connected to LEDs as output and set their default
	// initial state to high (LEDs off).
	gpio_configure_pin(LED0_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002016:	30 3b       	mov	r11,3
80002018:	30 8c       	mov	r12,8
8000201a:	f0 1f 00 13 	mcall	80002064 <board_init+0x60>
	gpio_configure_pin(LED1_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000201e:	30 3b       	mov	r11,3
80002020:	37 7c       	mov	r12,119
80002022:	f0 1f 00 11 	mcall	80002064 <board_init+0x60>
	gpio_configure_pin(LED2_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002026:	30 3b       	mov	r11,3
80002028:	34 dc       	mov	r12,77
8000202a:	f0 1f 00 0f 	mcall	80002064 <board_init+0x60>
	gpio_configure_pin(LED3_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000202e:	30 3b       	mov	r11,3
80002030:	37 6c       	mov	r12,118
80002032:	f0 1f 00 0d 	mcall	80002064 <board_init+0x60>

	// Configure the pin connected to the button 0 and 1 button as input.
	gpio_configure_pin(GPIO_PUSH_BUTTON_0,GPIO_DIR_INPUT);
80002036:	30 0b       	mov	r11,0
80002038:	30 ec       	mov	r12,14
8000203a:	f0 1f 00 0b 	mcall	80002064 <board_init+0x60>
	gpio_configure_pin(GPIO_PUSH_BUTTON_1,GPIO_DIR_INPUT);
8000203e:	30 0b       	mov	r11,0
80002040:	31 dc       	mov	r12,29
80002042:	f0 1f 00 09 	mcall	80002064 <board_init+0x60>
	// USART GPIO pin configuration.
	static const gpio_map_t COMPORT_GPIO_MAP = {
		{USART_RXD_PIN, USART_RXD_FUNCTION},
		{USART_TXD_PIN, USART_TXD_FUNCTION},
	};
	gpio_enable_module(COMPORT_GPIO_MAP,
80002046:	30 2b       	mov	r11,2
80002048:	48 8c       	lddpc	r12,80002068 <board_init+0x64>
8000204a:	f0 1f 00 05 	mcall	8000205c <board_init+0x58>
		{AVR32_TWIMS0_TWD_0_0_PIN, AVR32_TWIMS0_TWD_0_0_FUNCTION},
		{AVR32_TWIMS0_TWCK_0_0_PIN, AVR32_TWIMS0_TWCK_0_0_FUNCTION},
	};

	// TWI gpio pins cofiguration
	gpio_enable_module(TWI_GPIO_MAP,
8000204e:	30 2b       	mov	r11,2
80002050:	48 7c       	lddpc	r12,8000206c <board_init+0x68>
80002052:	f0 1f 00 03 	mcall	8000205c <board_init+0x58>
			sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
#endif
}
80002056:	d8 02       	popm	pc
80002058:	80 00       	ld.sh	r0,r0[0x0]
8000205a:	46 04       	lddsp	r4,sp[0x180]
8000205c:	80 00       	ld.sh	r0,r0[0x0]
8000205e:	21 04       	sub	r4,16
80002060:	80 00       	ld.sh	r0,r0[0x0]
80002062:	46 0c       	lddsp	r12,sp[0x180]
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	21 34       	sub	r4,19
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	46 14       	lddsp	r4,sp[0x184]
8000206c:	80 00       	ld.sh	r0,r0[0x0]
8000206e:	46 00       	lddsp	r0,sp[0x180]

80002070 <gpio_enable_module_pin>:
}


int gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002070:	f8 08 16 05 	lsr	r8,r12,0x5
80002074:	a9 78       	lsl	r8,0x9
80002076:	e0 28 e0 00 	sub	r8,57344

  // Enable the correct function.
  switch (function)
8000207a:	58 7b       	cp.w	r11,7
8000207c:	e0 8b 00 05 	brhi	80002086 <gpio_enable_module_pin+0x16>
80002080:	4a 09       	lddpc	r9,80002100 <gpio_enable_module_pin+0x90>
80002082:	f2 0b 03 2f 	ld.w	pc,r9[r11<<0x2]
80002086:	5e ff       	retal	1
  {
  case 0: // A function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
80002088:	30 19       	mov	r9,1
8000208a:	f2 0c 09 49 	lsl	r9,r9,r12
8000208e:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
80002090:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
80002092:	91 e9       	st.w	r8[0x38],r9
#endif
    break;
80002094:	c3 18       	rjmp	800020f6 <gpio_enable_module_pin+0x86>

  case 1: // B function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
80002096:	30 19       	mov	r9,1
80002098:	f2 0c 09 49 	lsl	r9,r9,r12
8000209c:	91 59       	st.w	r8[0x14],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
8000209e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
800020a0:	91 e9       	st.w	r8[0x38],r9
#endif
    break;
800020a2:	c2 a8       	rjmp	800020f6 <gpio_enable_module_pin+0x86>

  case 2: // C function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
800020a4:	30 19       	mov	r9,1
800020a6:	f2 0c 09 49 	lsl	r9,r9,r12
800020aa:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1s = 1 << (pin & 0x1F);
800020ac:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
800020ae:	91 e9       	st.w	r8[0x38],r9
#endif
    break;
800020b0:	c2 38       	rjmp	800020f6 <gpio_enable_module_pin+0x86>

  case 3: // D function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
800020b2:	30 19       	mov	r9,1
800020b4:	f2 0c 09 49 	lsl	r9,r9,r12
800020b8:	91 59       	st.w	r8[0x14],r9
    gpio_port->pmr1s = 1 << (pin & 0x1F);
800020ba:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
800020bc:	91 e9       	st.w	r8[0x38],r9
#endif
    break;
800020be:	c1 c8       	rjmp	800020f6 <gpio_enable_module_pin+0x86>

#if (AVR32_GPIO_H_VERSION >= 210)
  case 4: // E function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
800020c0:	30 19       	mov	r9,1
800020c2:	f2 0c 09 49 	lsl	r9,r9,r12
800020c6:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
800020c8:	91 a9       	st.w	r8[0x28],r9
    gpio_port->pmr2s = 1 << (pin & 0x1F);
800020ca:	91 d9       	st.w	r8[0x34],r9
    break;
800020cc:	c1 58       	rjmp	800020f6 <gpio_enable_module_pin+0x86>

  case 5: // F function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
800020ce:	30 19       	mov	r9,1
800020d0:	f2 0c 09 49 	lsl	r9,r9,r12
800020d4:	91 59       	st.w	r8[0x14],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
800020d6:	91 a9       	st.w	r8[0x28],r9
    gpio_port->pmr2s = 1 << (pin & 0x1F);
800020d8:	91 d9       	st.w	r8[0x34],r9
    break;
800020da:	c0 e8       	rjmp	800020f6 <gpio_enable_module_pin+0x86>

  case 6: // G function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
800020dc:	30 19       	mov	r9,1
800020de:	f2 0c 09 49 	lsl	r9,r9,r12
800020e2:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1s = 1 << (pin & 0x1F);
800020e4:	91 99       	st.w	r8[0x24],r9
    gpio_port->pmr2s = 1 << (pin & 0x1F);
800020e6:	91 d9       	st.w	r8[0x34],r9
    break;
800020e8:	c0 78       	rjmp	800020f6 <gpio_enable_module_pin+0x86>

  case 7: // H function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
800020ea:	30 19       	mov	r9,1
800020ec:	f2 0c 09 49 	lsl	r9,r9,r12
800020f0:	91 59       	st.w	r8[0x14],r9
    gpio_port->pmr1s = 1 << (pin & 0x1F);
800020f2:	91 99       	st.w	r8[0x24],r9
    gpio_port->pmr2s = 1 << (pin & 0x1F);
800020f4:	91 d9       	st.w	r8[0x34],r9
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
800020f6:	30 19       	mov	r9,1
800020f8:	f2 0c 09 4c 	lsl	r12,r9,r12
800020fc:	91 2c       	st.w	r8[0x8],r12
800020fe:	5e fd       	retal	0
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	46 18       	lddsp	r8,sp[0x184]

80002104 <gpio_enable_module>:
 */
//! @{


int gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002104:	d4 21       	pushm	r4-r7,lr
80002106:	18 97       	mov	r7,r12
80002108:	16 94       	mov	r4,r11
  int status = GPIO_SUCCESS;
  uint32_t i;

  for (i = 0; i < size; i++)
8000210a:	58 0b       	cp.w	r11,0
8000210c:	c0 31       	brne	80002112 <gpio_enable_module+0xe>
8000210e:	30 05       	mov	r5,0
80002110:	c0 d8       	rjmp	8000212a <gpio_enable_module+0x26>
80002112:	30 06       	mov	r6,0
80002114:	0c 95       	mov	r5,r6
  {
    status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80002116:	0f 9b       	ld.ub	r11,r7[0x1]
80002118:	0f 8c       	ld.ub	r12,r7[0x0]
8000211a:	f0 1f 00 06 	mcall	80002130 <gpio_enable_module+0x2c>
8000211e:	18 45       	or	r5,r12
    gpiomap++;
80002120:	2f e7       	sub	r7,-2
int gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
  int status = GPIO_SUCCESS;
  uint32_t i;

  for (i = 0; i < size; i++)
80002122:	2f f6       	sub	r6,-1
80002124:	0c 34       	cp.w	r4,r6
80002126:	fe 9b ff f8 	brhi	80002116 <gpio_enable_module+0x12>
    status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
    gpiomap++;
  }

  return status;
}
8000212a:	0a 9c       	mov	r12,r5
8000212c:	d8 22       	popm	r4-r7,pc
8000212e:	00 00       	add	r0,r0
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	20 70       	sub	r0,7

80002134 <gpio_configure_pin>:

#endif

void gpio_configure_pin(uint32_t pin, uint32_t flags)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002134:	f8 08 16 05 	lsr	r8,r12,0x5
80002138:	a9 78       	lsl	r8,0x9
8000213a:	e0 28 e0 00 	sub	r8,57344

  /* Both pull-up and pull-down set means buskeeper */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_212_H_INCLUDED)
    if (flags & GPIO_PULL_DOWN)
8000213e:	16 99       	mov	r9,r11
80002140:	e2 19 00 08 	andl	r9,0x8,COH
80002144:	c0 70       	breq	80002152 <gpio_configure_pin+0x1e>
            gpio_port->pders = 1 << (pin & 0x1F);
80002146:	30 19       	mov	r9,1
80002148:	f2 0c 09 49 	lsl	r9,r9,r12
8000214c:	f1 49 00 84 	st.w	r8[132],r9
80002150:	c0 68       	rjmp	8000215c <gpio_configure_pin+0x28>
    else
            gpio_port->pderc = 1 << (pin & 0x1F);
80002152:	30 19       	mov	r9,1
80002154:	f2 0c 09 49 	lsl	r9,r9,r12
80002158:	f1 49 00 88 	st.w	r8[136],r9
#endif
    if (flags & GPIO_PULL_UP)
8000215c:	16 99       	mov	r9,r11
8000215e:	e2 19 00 04 	andl	r9,0x4,COH
80002162:	c0 70       	breq	80002170 <gpio_configure_pin+0x3c>
            gpio_port->puers = 1 << (pin & 0x1F);
80002164:	30 19       	mov	r9,1
80002166:	f2 0c 09 49 	lsl	r9,r9,r12
8000216a:	f1 49 00 74 	st.w	r8[116],r9
8000216e:	c0 68       	rjmp	8000217a <gpio_configure_pin+0x46>
    else
            gpio_port->puerc = 1 << (pin & 0x1F);
80002170:	30 19       	mov	r9,1
80002172:	f2 0c 09 49 	lsl	r9,r9,r12
80002176:	f1 49 00 78 	st.w	r8[120],r9

    /* Enable open-drain mode if requested */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_212_H_INCLUDED)
            if (flags & GPIO_OPEN_DRAIN)
8000217a:	16 99       	mov	r9,r11
8000217c:	e2 19 00 40 	andl	r9,0x40,COH
80002180:	c0 90       	breq	80002192 <gpio_configure_pin+0x5e>
                    gpio_port->odmers = 1 << (pin & 0x1F);
80002182:	30 19       	mov	r9,1
80002184:	f2 0c 09 49 	lsl	r9,r9,r12
80002188:	f1 49 00 e4 	st.w	r8[228],r9
            else
                    gpio_port->odmerc = 1 << (pin & 0x1F);

            if (flags & GPIO_OPEN_DRAIN)
                    gpio_port->pders = 1 << (pin & 0x1F);
8000218c:	f1 49 00 84 	st.w	r8[132],r9
80002190:	c0 88       	rjmp	800021a0 <gpio_configure_pin+0x6c>
    /* Enable open-drain mode if requested */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_212_H_INCLUDED)
            if (flags & GPIO_OPEN_DRAIN)
                    gpio_port->odmers = 1 << (pin & 0x1F);
            else
                    gpio_port->odmerc = 1 << (pin & 0x1F);
80002192:	30 19       	mov	r9,1
80002194:	f2 0c 09 49 	lsl	r9,r9,r12
80002198:	f1 49 00 e8 	st.w	r8[232],r9

            if (flags & GPIO_OPEN_DRAIN)
                    gpio_port->pders = 1 << (pin & 0x1F);
            else
                    gpio_port->pderc = 1 << (pin & 0x1F);
8000219c:	f1 49 00 88 	st.w	r8[136],r9
#endif

#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_212_H_INCLUDED)
            /* Select drive strength */
            if (flags & GPIO_DRIVE_LOW)
800021a0:	16 99       	mov	r9,r11
800021a2:	e2 19 00 10 	andl	r9,0x10,COH
800021a6:	c0 70       	breq	800021b4 <gpio_configure_pin+0x80>
                    gpio_port->odcr0s = 1 << (pin & 0x1F);
800021a8:	30 19       	mov	r9,1
800021aa:	f2 0c 09 49 	lsl	r9,r9,r12
800021ae:	f1 49 01 04 	st.w	r8[260],r9
800021b2:	c0 68       	rjmp	800021be <gpio_configure_pin+0x8a>
            else
                    gpio_port->odcr0c = 1 << (pin & 0x1F);
800021b4:	30 19       	mov	r9,1
800021b6:	f2 0c 09 49 	lsl	r9,r9,r12
800021ba:	f1 49 01 08 	st.w	r8[264],r9
            if (flags & GPIO_DRIVE_HIGH)
800021be:	16 99       	mov	r9,r11
800021c0:	e2 19 00 20 	andl	r9,0x20,COH
800021c4:	c0 70       	breq	800021d2 <gpio_configure_pin+0x9e>
                    gpio_port->odcr1s = 1 << (pin & 0x1F);
800021c6:	30 19       	mov	r9,1
800021c8:	f2 0c 09 49 	lsl	r9,r9,r12
800021cc:	f1 49 01 14 	st.w	r8[276],r9
800021d0:	c0 68       	rjmp	800021dc <gpio_configure_pin+0xa8>
            else
                    gpio_port->odcr1c = 1 << (pin & 0x1F);
800021d2:	30 19       	mov	r9,1
800021d4:	f2 0c 09 49 	lsl	r9,r9,r12
800021d8:	f1 49 01 18 	st.w	r8[280],r9
#endif

    /* Select interrupt level for group */
    if (flags & GPIO_INTERRUPT) {
800021dc:	16 99       	mov	r9,r11
800021de:	e2 19 00 80 	andl	r9,0x80,COH
800021e2:	c2 40       	breq	8000222a <gpio_configure_pin+0xf6>
            if (flags & GPIO_BOTHEDGES)
800021e4:	16 99       	mov	r9,r11
800021e6:	e2 19 01 80 	andl	r9,0x180,COH
800021ea:	c0 90       	breq	800021fc <gpio_configure_pin+0xc8>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
800021ec:	30 19       	mov	r9,1
800021ee:	f2 0c 09 49 	lsl	r9,r9,r12
800021f2:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
800021f6:	f1 49 00 b8 	st.w	r8[184],r9
800021fa:	c1 88       	rjmp	8000222a <gpio_configure_pin+0xf6>
            }
            else if (flags & GPIO_RISING)
800021fc:	16 99       	mov	r9,r11
800021fe:	e2 19 02 80 	andl	r9,0x280,COH
80002202:	c0 90       	breq	80002214 <gpio_configure_pin+0xe0>
            {
                   gpio_port->imr0s = 1 << (pin & 0x1F);
80002204:	30 19       	mov	r9,1
80002206:	f2 0c 09 49 	lsl	r9,r9,r12
8000220a:	f1 49 00 a4 	st.w	r8[164],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
8000220e:	f1 49 00 b8 	st.w	r8[184],r9
80002212:	c0 c8       	rjmp	8000222a <gpio_configure_pin+0xf6>
            }
            else if (flags & GPIO_FALLING)
80002214:	16 99       	mov	r9,r11
80002216:	e2 19 03 80 	andl	r9,0x380,COH
8000221a:	c0 80       	breq	8000222a <gpio_configure_pin+0xf6>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
8000221c:	30 19       	mov	r9,1
8000221e:	f2 0c 09 49 	lsl	r9,r9,r12
80002222:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1s = 1 << (pin & 0x1F);
80002226:	f1 49 00 b4 	st.w	r8[180],r9
            }
    }

    /* Select direction and initial pin state */
    if (flags & GPIO_DIR_OUTPUT) {
8000222a:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
8000222e:	c1 50       	breq	80002258 <gpio_configure_pin+0x124>
            if (flags & GPIO_INIT_HIGH)
80002230:	e2 1b 00 02 	andl	r11,0x2,COH
80002234:	c0 70       	breq	80002242 <gpio_configure_pin+0x10e>
                    gpio_port->ovrs = 1 << (pin & 0x1F);
80002236:	30 19       	mov	r9,1
80002238:	f2 0c 09 49 	lsl	r9,r9,r12
8000223c:	f1 49 00 54 	st.w	r8[84],r9
80002240:	c0 68       	rjmp	8000224c <gpio_configure_pin+0x118>
            else
                    gpio_port->ovrc = 1 << (pin & 0x1F);
80002242:	30 19       	mov	r9,1
80002244:	f2 0c 09 49 	lsl	r9,r9,r12
80002248:	f1 49 00 58 	st.w	r8[88],r9
            gpio_port->oders = 1 << (pin & 0x1F);
8000224c:	30 19       	mov	r9,1
8000224e:	f2 0c 09 49 	lsl	r9,r9,r12
80002252:	f1 49 00 44 	st.w	r8[68],r9
80002256:	c0 68       	rjmp	80002262 <gpio_configure_pin+0x12e>
    } else {
            gpio_port->oderc = 1 << (pin & 0x1F);
80002258:	30 19       	mov	r9,1
8000225a:	f2 0c 09 49 	lsl	r9,r9,r12
8000225e:	f1 49 00 48 	st.w	r8[72],r9
    }

    /* Enable GPIO */
    gpio_port->gpers = 1 << (pin & 0x1F);
80002262:	30 19       	mov	r9,1
80002264:	f2 0c 09 4c 	lsl	r12,r9,r12
80002268:	91 1c       	st.w	r8[0x4],r12
}
8000226a:	5e fc       	retal	r12

8000226c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000226c:	c0 08       	rjmp	8000226c <_unhandled_interrupt>
8000226e:	d7 03       	nop

80002270 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002270:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80002274:	49 99       	lddpc	r9,800022d8 <INTC_register_interrupt+0x68>
80002276:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000227a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000227e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80002280:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80002284:	58 0a       	cp.w	r10,0
80002286:	c0 91       	brne	80002298 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002288:	49 59       	lddpc	r9,800022dc <INTC_register_interrupt+0x6c>
8000228a:	49 6a       	lddpc	r10,800022e0 <INTC_register_interrupt+0x70>
8000228c:	12 1a       	sub	r10,r9
8000228e:	fe 79 00 00 	mov	r9,-65536
80002292:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80002296:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80002298:	58 1a       	cp.w	r10,1
8000229a:	c0 a1       	brne	800022ae <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000229c:	49 09       	lddpc	r9,800022dc <INTC_register_interrupt+0x6c>
8000229e:	49 2a       	lddpc	r10,800022e4 <INTC_register_interrupt+0x74>
800022a0:	12 1a       	sub	r10,r9
800022a2:	bf aa       	sbr	r10,0x1e
800022a4:	fe 79 00 00 	mov	r9,-65536
800022a8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800022ac:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800022ae:	58 2a       	cp.w	r10,2
800022b0:	c0 a1       	brne	800022c4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800022b2:	48 b9       	lddpc	r9,800022dc <INTC_register_interrupt+0x6c>
800022b4:	48 da       	lddpc	r10,800022e8 <INTC_register_interrupt+0x78>
800022b6:	12 1a       	sub	r10,r9
800022b8:	bf ba       	sbr	r10,0x1f
800022ba:	fe 79 00 00 	mov	r9,-65536
800022be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800022c2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800022c4:	48 69       	lddpc	r9,800022dc <INTC_register_interrupt+0x6c>
800022c6:	48 aa       	lddpc	r10,800022ec <INTC_register_interrupt+0x7c>
800022c8:	12 1a       	sub	r10,r9
800022ca:	ea 1a c0 00 	orh	r10,0xc000
800022ce:	fe 79 00 00 	mov	r9,-65536
800022d2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800022d6:	5e fc       	retal	r12
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	46 38       	lddsp	r8,sp[0x18c]
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	44 00       	lddsp	r0,sp[0x100]
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	45 04       	lddsp	r4,sp[0x140]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	45 12       	lddsp	r2,sp[0x144]
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	45 20       	lddsp	r0,sp[0x148]
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	45 2e       	lddsp	lr,sp[0x148]

800022f0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800022f0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800022f2:	49 18       	lddpc	r8,80002334 <INTC_init_interrupts+0x44>
800022f4:	e3 b8 00 01 	mtsr	0x4,r8
800022f8:	49 0e       	lddpc	lr,80002338 <INTC_init_interrupts+0x48>
800022fa:	30 07       	mov	r7,0
800022fc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800022fe:	49 0c       	lddpc	r12,8000233c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002300:	49 05       	lddpc	r5,80002340 <INTC_init_interrupts+0x50>
80002302:	10 15       	sub	r5,r8
80002304:	fe 76 00 00 	mov	r6,-65536
80002308:	c1 18       	rjmp	8000232a <INTC_init_interrupts+0x3a>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000230a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000230c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000230e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002310:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80002314:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002316:	10 3a       	cp.w	r10,r8
80002318:	fe 9b ff fc 	brhi	80002310 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000231c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002320:	2f f7       	sub	r7,-1
80002322:	2f 8e       	sub	lr,-8
80002324:	e0 47 00 2f 	cp.w	r7,47
80002328:	c0 50       	breq	80002332 <INTC_init_interrupts+0x42>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000232a:	7c 08       	ld.w	r8,lr[0x0]
8000232c:	58 08       	cp.w	r8,0
8000232e:	ce e1       	brne	8000230a <INTC_init_interrupts+0x1a>
80002330:	cf 6b       	rjmp	8000231c <INTC_init_interrupts+0x2c>
80002332:	d8 22       	popm	r4-r7,pc
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	44 00       	lddsp	r0,sp[0x100]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	46 38       	lddsp	r8,sp[0x18c]
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	22 6c       	sub	r12,38
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	45 04       	lddsp	r4,sp[0x140]

80002344 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002344:	fe 78 00 00 	mov	r8,-65536
80002348:	e0 69 00 83 	mov	r9,131
8000234c:	f2 0c 01 0c 	sub	r12,r9,r12
80002350:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002354:	f2 ca ff c0 	sub	r10,r9,-64
80002358:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000235c:	58 08       	cp.w	r8,0
8000235e:	c0 21       	brne	80002362 <_get_interrupt_handler+0x1e>
80002360:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002362:	f0 08 12 00 	clz	r8,r8
80002366:	48 5a       	lddpc	r10,80002378 <_get_interrupt_handler+0x34>
80002368:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000236c:	f0 08 11 1f 	rsub	r8,r8,31
80002370:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002372:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80002376:	5e fc       	retal	r12
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	46 38       	lddsp	r8,sp[0x18c]

8000237c <udd_include_vbus_monitoring>:
#if ( UC3L3_L4 )
	return false;
#else
	return true;
#endif
}
8000237c:	5e ff       	retal	1

8000237e <udd_is_high_speed>:
#ifdef USB_DEVICE_HS_SUPPORT
	return !Is_udd_full_speed_mode();
#else
	return false;
#endif
}
8000237e:	5e fd       	retal	0

80002380 <udd_set_address>:


void udd_set_address(uint8_t address)
{
	udd_disable_address();
80002380:	fe 68 10 00 	mov	r8,-126976
80002384:	70 09       	ld.w	r9,r8[0x0]
80002386:	a7 d9       	cbr	r9,0x7
80002388:	91 09       	st.w	r8[0x0],r9
	udd_configure_address(address);
8000238a:	70 09       	ld.w	r9,r8[0x0]
8000238c:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
80002390:	e0 19 ff 80 	andl	r9,0xff80
80002394:	f9 e9 10 09 	or	r9,r12,r9
80002398:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
8000239a:	70 09       	ld.w	r9,r8[0x0]
8000239c:	a7 b9       	sbr	r9,0x7
8000239e:	91 09       	st.w	r8[0x0],r9
}
800023a0:	5e fc       	retal	r12

800023a2 <udd_getaddress>:


uint8_t udd_getaddress(void)
{
	return udd_get_configured_address();
800023a2:	fe 68 10 00 	mov	r8,-126976
800023a6:	70 0c       	ld.w	r12,r8[0x0]
}
800023a8:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800023ac:	5e fc       	retal	r12

800023ae <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
	return udd_frame_number();
800023ae:	fe 68 10 20 	mov	r8,-126944
800023b2:	70 0c       	ld.w	r12,r8[0x0]
}
800023b4:	f9 dc c0 6b 	bfextu	r12,r12,0x3,0xb
800023b8:	5e fc       	retal	r12

800023ba <udd_get_micro_frame_number>:
#ifdef USB_DEVICE_HS_SUPPORT
	return udd_micro_frame_number();
#else
	return 0;
#endif
}
800023ba:	5e fd       	retal	0

800023bc <udd_set_setup_payload>:
}


void udd_set_setup_payload( uint8_t *payload, uint16_t payload_size )
{
	udd_g_ctrlreq.payload = payload;
800023bc:	48 28       	lddpc	r8,800023c4 <udd_set_setup_payload+0x8>
800023be:	91 2c       	st.w	r8[0x8],r12
	udd_g_ctrlreq.payload_size = payload_size;
800023c0:	b0 6b       	st.h	r8[0xc],r11
}
800023c2:	5e fc       	retal	r12
800023c4:	00 00       	add	r0,r0
800023c6:	05 7c       	ld.ub	r12,--r2

800023c8 <udd_ep_is_halted>:
}


bool udd_ep_is_halted(udd_ep_id_t ep)
{
	return Is_udd_endpoint_stall_requested(ep & USB_EP_ADDR_MASK);
800023c8:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
800023cc:	a3 68       	lsl	r8,0x2
800023ce:	e0 38 ee 40 	sub	r8,126528
800023d2:	70 0c       	ld.w	r12,r8[0x0]
}
800023d4:	f9 dc c2 61 	bfextu	r12,r12,0x13,0x1
800023d8:	5e fc       	retal	r12
800023da:	d7 03       	nop

800023dc <udd_ep_clear_halt>:
	return true;
}


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
800023dc:	d4 01       	pushm	lr
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
800023de:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
800023e2:	30 38       	mov	r8,3
800023e4:	f0 0c 18 00 	cp.b	r12,r8
800023e8:	e0 88 00 03 	brls	800023ee <udd_ep_clear_halt+0x12>
800023ec:	d8 0a       	popm	pc,r12=0
		return false;
	ptr_job = &udd_ep_job[ep - 1];

	if (Is_udd_endpoint_stall_requested(ep)) { // Endpoint stalled
800023ee:	f8 08 15 02 	lsl	r8,r12,0x2
800023f2:	fe 6a 11 c0 	mov	r10,-126528
800023f6:	f0 0a 00 09 	add	r9,r8,r10
800023fa:	72 09       	ld.w	r9,r9[0x0]
800023fc:	e6 19 00 08 	andh	r9,0x8,COH
80002400:	c1 60       	breq	8000242c <udd_ep_clear_halt+0x50>
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
	if (USB_DEVICE_MAX_EP < ep)
		return false;
	ptr_job = &udd_ep_job[ep - 1];
80002402:	20 1c       	sub	r12,1
80002404:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80002408:	48 a9       	lddpc	r9,80002430 <udd_ep_clear_halt+0x54>
8000240a:	f2 0c 00 2c 	add	r12,r9,r12<<0x2

	if (Is_udd_endpoint_stall_requested(ep)) { // Endpoint stalled
		// Remove stall
		udd_disable_stall_handshake(ep);
8000240e:	e0 38 ed e0 	sub	r8,126432
80002412:	e8 69 00 00 	mov	r9,524288
80002416:	91 09       	st.w	r8[0x0],r9

		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
80002418:	78 08       	ld.w	r8,r12[0x0]
8000241a:	58 08       	cp.w	r8,0
8000241c:	c0 84       	brge	8000242c <udd_ep_clear_halt+0x50>
			ptr_job->busy = false;
8000241e:	30 09       	mov	r9,0
80002420:	f1 d9 d3 e1 	bfins	r8,r9,0x1f,0x1
80002424:	99 08       	st.w	r12[0x0],r8
			ptr_job->call_nohalt();
80002426:	78 48       	ld.w	r8,r12[0x10]
80002428:	5d 18       	icall	r8
8000242a:	da 0a       	popm	pc,r12=1
8000242c:	da 0a       	popm	pc,r12=1
8000242e:	00 00       	add	r0,r0
80002430:	00 00       	add	r0,r0
80002432:	02 8c       	andn	r12,r1

80002434 <udd_ctrl_init>:
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI),
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
80002434:	30 19       	mov	r9,1
80002436:	fe 68 12 20 	mov	r8,-126432
8000243a:	91 09       	st.w	r8[0x0],r9
	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
8000243c:	30 29       	mov	r9,2
8000243e:	fe 68 11 60 	mov	r8,-126624
80002442:	91 09       	st.w	r8[0x0],r9

	udd_g_ctrlreq.callback = NULL;
80002444:	48 49       	lddpc	r9,80002454 <udd_ctrl_init+0x20>
80002446:	30 08       	mov	r8,0
80002448:	93 48       	st.w	r9[0x10],r8
	udd_g_ctrlreq.over_under_run = NULL;
8000244a:	93 58       	st.w	r9[0x14],r8
	udd_g_ctrlreq.payload_size = 0;
8000244c:	b2 68       	st.h	r9[0xc],r8
	udd_ep_control_state = UDD_EPCTRL_SETUP;
8000244e:	48 39       	lddpc	r9,80002458 <udd_ctrl_init+0x24>
80002450:	93 08       	st.w	r9[0x0],r8
}
80002452:	5e fc       	retal	r12
80002454:	00 00       	add	r0,r0
80002456:	05 7c       	ld.ub	r12,--r2
80002458:	00 00       	add	r0,r0
8000245a:	03 64       	ld.uh	r4,--r1

8000245c <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
8000245c:	30 59       	mov	r9,5
8000245e:	48 58       	lddpc	r8,80002470 <udd_ctrl_stall_data+0x14>
80002460:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(0);
80002462:	e8 69 00 00 	mov	r9,524288
80002466:	fe 68 11 f0 	mov	r8,-126480
8000246a:	91 09       	st.w	r8[0x0],r9
}
8000246c:	5e fc       	retal	r12
8000246e:	00 00       	add	r0,r0
80002470:	00 00       	add	r0,r0
80002472:	03 64       	ld.uh	r4,--r1

80002474 <udd_ctrl_endofrequest>:
	cpu_irq_restore(flags);
}


static void udd_ctrl_endofrequest(void)
{
80002474:	d4 01       	pushm	lr
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
80002476:	48 48       	lddpc	r8,80002484 <udd_ctrl_endofrequest+0x10>
80002478:	70 48       	ld.w	r8,r8[0x10]
8000247a:	58 08       	cp.w	r8,0
8000247c:	c0 20       	breq	80002480 <udd_ctrl_endofrequest+0xc>
		udd_g_ctrlreq.callback();
8000247e:	5d 18       	icall	r8
80002480:	d8 02       	popm	pc
80002482:	00 00       	add	r0,r0
80002484:	00 00       	add	r0,r0
80002486:	05 7c       	ld.ub	r12,--r2

80002488 <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
80002488:	eb cd 40 e0 	pushm	r5-r7,lr
	uint8_t ep_addr = ep & USB_EP_ADDR_MASK;
8000248c:	f3 dc c0 04 	bfextu	r9,r12,0x0,0x4
	if (Is_udd_endpoint_enabled(ep_addr)) {
80002490:	fe 68 10 00 	mov	r8,-126976
80002494:	70 7e       	ld.w	lr,r8[0x1c]
80002496:	30 18       	mov	r8,1
80002498:	f0 09 09 48 	lsl	r8,r8,r9
8000249c:	f1 ee 00 0e 	and	lr,r8,lr
800024a0:	c0 30       	breq	800024a6 <udd_ep_alloc+0x1e>
800024a2:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
	// Check endpoint type
	Assert(((bmAttributes & USB_EP_TYPE_MASK) == USB_EP_TYPE_ISOCHRONOUS)
			|| ((bmAttributes & USB_EP_TYPE_MASK) == USB_EP_TYPE_BULK)
			|| ((bmAttributes & USB_EP_TYPE_MASK) == USB_EP_TYPE_INTERRUPT));

	udd_configure_endpoint(ep_addr, bmAttributes,
800024a6:	a3 69       	lsl	r9,0x2
800024a8:	fe 67 11 00 	mov	r7,-126720
800024ac:	f2 07 00 0e 	add	lr,r9,r7
800024b0:	7c 06       	ld.w	r6,lr[0x0]
800024b2:	30 07       	mov	r7,0
800024b4:	e0 65 01 00 	mov	r5,256
800024b8:	f8 07 18 00 	cp.b	r7,r12
800024bc:	ea 07 17 90 	movgt	r7,r5
800024c0:	f9 b7 0a 00 	movle	r7,0
800024c4:	5c 7a       	castu.h	r10
800024c6:	30 8c       	mov	r12,8
800024c8:	f4 0c 0c 4a 	max	r10,r10,r12
800024cc:	e0 6c 04 00 	mov	r12,1024
800024d0:	f4 0c 0d 4a 	min	r10,r10,r12
800024d4:	a1 7a       	lsl	r10,0x1
800024d6:	20 1a       	sub	r10,1
800024d8:	f4 0a 12 00 	clz	r10,r10
800024dc:	ab 7b       	lsl	r11,0xb
800024de:	e2 1b 18 00 	andl	r11,0x1800,COH
800024e2:	16 47       	or	r7,r11
800024e4:	f4 0c 11 1c 	rsub	r12,r10,28
800024e8:	ef ec 10 4c 	or	r12,r7,r12<<0x4
800024ec:	e2 1c 19 74 	andl	r12,0x1974,COH
800024f0:	0c 9a       	mov	r10,r6
800024f2:	e0 1a e6 8b 	andl	r10,0xe68b
800024f6:	f9 ea 10 0a 	or	r10,r12,r10
800024fa:	9d 0a       	st.w	lr[0x0],r10
			((ep & USB_EP_DIR_IN) ? 1 : 0), MaxEndpointSize,
			AVR32_USBC_UECFG0_EPBK_SINGLE);

	udd_enable_busy_bank0(ep_addr);
800024fc:	e0 39 ee 10 	sub	r9,126480
80002500:	fc 1a 01 00 	movh	r10,0x100
80002504:	93 0a       	st.w	r9[0x0],r10
	udd_enable_endpoint(ep_addr);
80002506:	fe 69 10 00 	mov	r9,-126976
8000250a:	72 7a       	ld.w	r10,r9[0x1c]
8000250c:	14 48       	or	r8,r10
8000250e:	93 78       	st.w	r9[0x1c],r8
80002510:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1

80002514 <udd_sleep_mode>:
 *
 * \param b_enable   true to authorize powerdown mode
 */
static void udd_sleep_mode(bool b_idle)
{
	if (!b_idle && udd_b_idle) {
80002514:	58 0c       	cp.w	r12,0
80002516:	c1 11       	brne	80002538 <udd_sleep_mode+0x24>
80002518:	49 18       	lddpc	r8,8000255c <udd_sleep_mode+0x48>
8000251a:	11 89       	ld.ub	r9,r8[0x0]
8000251c:	30 08       	mov	r8,0
8000251e:	f0 09 18 00 	cp.b	r9,r8
80002522:	c1 a0       	breq	80002556 <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002524:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002528:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode]);

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
8000252a:	48 e8       	lddpc	r8,80002560 <udd_sleep_mode+0x4c>
8000252c:	11 9a       	ld.ub	r10,r8[0x1]
8000252e:	20 1a       	sub	r10,1
80002530:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002532:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002536:	c1 08       	rjmp	80002556 <udd_sleep_mode+0x42>
		sleepmgr_unlock_mode(USBC_SLEEP_MODE_USB_IDLE);
	}
	if (b_idle && !udd_b_idle) {
80002538:	48 98       	lddpc	r8,8000255c <udd_sleep_mode+0x48>
8000253a:	11 89       	ld.ub	r9,r8[0x0]
8000253c:	30 08       	mov	r8,0
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 a1       	brne	80002556 <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002544:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002548:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
8000254a:	48 68       	lddpc	r8,80002560 <udd_sleep_mode+0x4c>
8000254c:	11 9a       	ld.ub	r10,r8[0x1]
8000254e:	2f fa       	sub	r10,-1
80002550:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002552:	e3 b9 00 00 	mtsr	0x0,r9
		sleepmgr_lock_mode(USBC_SLEEP_MODE_USB_IDLE);
	}
	udd_b_idle = b_idle;
80002556:	48 28       	lddpc	r8,8000255c <udd_sleep_mode+0x48>
80002558:	b0 8c       	st.b	r8[0x0],r12
}
8000255a:	5e fc       	retal	r12
8000255c:	00 00       	add	r0,r0
8000255e:	03 60       	ld.uh	r0,--r1
80002560:	00 00       	add	r0,r0
80002562:	05 d4       	ld.ub	r4,r2[0x5]

80002564 <udd_detach>:
	cpu_irq_restore(flags);
}


void udd_detach(void)
{
80002564:	d4 01       	pushm	lr
	otg_unfreeze_clock();
80002566:	fe 68 18 00 	mov	r8,-124928
8000256a:	70 09       	ld.w	r9,r8[0x0]
8000256c:	af c9       	cbr	r9,0xe
8000256e:	91 09       	st.w	r8[0x0],r9

	// Detach device from the bus
	udd_detach_device();
80002570:	fe 69 10 00 	mov	r9,-126976
80002574:	72 0a       	ld.w	r10,r9[0x0]
80002576:	a9 aa       	sbr	r10,0x8
80002578:	93 0a       	st.w	r9[0x0],r10
	otg_freeze_clock();
8000257a:	70 09       	ld.w	r9,r8[0x0]
8000257c:	af a9       	sbr	r9,0xe
8000257e:	91 09       	st.w	r8[0x0],r9
	udd_sleep_mode(false);
80002580:	30 0c       	mov	r12,0
80002582:	f0 1f 00 02 	mcall	80002588 <udd_detach+0x24>
}
80002586:	d8 02       	popm	pc
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	25 14       	sub	r4,81

8000258c <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
8000258c:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002590:	e1 b7 00 00 	mfsr	r7,0x0
	cpu_irq_disable();
80002594:	d3 03       	ssrf	0x10
	irqflags_t flags;
	flags = cpu_irq_save();

	// At startup the USB bus state is unknown,
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
80002596:	30 1c       	mov	r12,1
80002598:	f0 1f 00 17 	mcall	800025f4 <udd_attach+0x68>
	otg_unfreeze_clock();
8000259c:	fe 68 18 00 	mov	r8,-124928
800025a0:	70 09       	ld.w	r9,r8[0x0]
800025a2:	af c9       	cbr	r9,0xe
800025a4:	91 09       	st.w	r8[0x0],r9
	while( !Is_otg_clock_usable() );
800025a6:	fe 68 18 04 	mov	r8,-124924
800025aa:	70 09       	ld.w	r9,r8[0x0]
800025ac:	e2 19 40 00 	andl	r9,0x4000,COH
800025b0:	cf d0       	breq	800025aa <udd_attach+0x1e>

	// Authorize attach if Vbus is present
	udd_attach_device();
800025b2:	fe 68 10 00 	mov	r8,-126976
800025b6:	70 09       	ld.w	r9,r8[0x0]
800025b8:	a9 c9       	cbr	r9,0x8
800025ba:	91 09       	st.w	r8[0x0],r9

	// Enable USB line events
	udd_enable_reset_interrupt();
800025bc:	fe 68 10 18 	mov	r8,-126952
800025c0:	30 8c       	mov	r12,8
800025c2:	91 0c       	st.w	r8[0x0],r12
	udd_enable_suspend_interrupt();
800025c4:	30 1a       	mov	r10,1
800025c6:	91 0a       	st.w	r8[0x0],r10
	udd_enable_wake_up_interrupt();
800025c8:	31 09       	mov	r9,16
800025ca:	91 09       	st.w	r8[0x0],r9
	udd_enable_sof_interrupt();
800025cc:	30 4b       	mov	r11,4
800025ce:	91 0b       	st.w	r8[0x0],r11

	// Reset following interupts flag
	udd_ack_reset();
800025d0:	fe 68 10 08 	mov	r8,-126968
800025d4:	91 0c       	st.w	r8[0x0],r12
	udd_ack_sof();
800025d6:	91 0b       	st.w	r8[0x0],r11

	// The first suspend interrupt must be forced
	udd_raise_suspend();
800025d8:	fe 6b 10 0c 	mov	r11,-126964
800025dc:	97 0a       	st.w	r11[0x0],r10
	udd_ack_wake_up();
800025de:	91 09       	st.w	r8[0x0],r9
	otg_freeze_clock();
800025e0:	fe 68 18 00 	mov	r8,-124928
800025e4:	70 09       	ld.w	r9,r8[0x0]
800025e6:	af a9       	sbr	r9,0xe
800025e8:	91 09       	st.w	r8[0x0],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800025ea:	e3 b7 00 00 	mtsr	0x0,r7
	cpu_irq_restore(flags);
}
800025ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800025f2:	00 00       	add	r0,r0
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	25 14       	sub	r4,81

800025f8 <udd_ctrl_send_zlp_in>:

static void udd_ctrl_send_zlp_in(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
800025f8:	30 39       	mov	r9,3
800025fa:	48 d8       	lddpc	r8,8000262c <udd_ctrl_send_zlp_in+0x34>
800025fc:	91 09       	st.w	r8[0x0],r9

	// Validate and send empty IN packet on control endpoint
	udd_udesc_rst_buf0_ctn(0);
800025fe:	48 d8       	lddpc	r8,80002630 <udd_ctrl_send_zlp_in+0x38>
80002600:	70 19       	ld.w	r9,r8[0x4]
80002602:	30 0a       	mov	r10,0
80002604:	f3 da d0 0f 	bfins	r9,r10,0x0,0xf
80002608:	91 19       	st.w	r8[0x4],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000260a:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
8000260e:	d3 03       	ssrf	0x10

	flags = cpu_irq_save();

	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
80002610:	fe 6a 11 60 	mov	r10,-126624
80002614:	30 19       	mov	r9,1
80002616:	95 09       	st.w	r10[0x0],r9
	udd_enable_in_send_interrupt(0);
80002618:	fe 68 11 f0 	mov	r8,-126480
8000261c:	91 09       	st.w	r8[0x0],r9

	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
8000261e:	30 89       	mov	r9,8
80002620:	95 09       	st.w	r10[0x0],r9
	udd_enable_nak_out_interrupt(0);
80002622:	91 09       	st.w	r8[0x0],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002624:	e3 bb 00 00 	mtsr	0x0,r11
	cpu_irq_restore(flags);
}
80002628:	5e fc       	retal	r12
8000262a:	00 00       	add	r0,r0
8000262c:	00 00       	add	r0,r0
8000262e:	03 64       	ld.uh	r4,--r1
80002630:	00 00       	add	r0,r0
80002632:	02 e0       	st.h	--r1,r0

80002634 <udd_ctrl_in_sent>:
	}
}


static void udd_ctrl_in_sent(void)
{
80002634:	eb cd 40 e0 	pushm	r5-r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002638:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
8000263c:	d3 03       	ssrf	0x10
	uint16_t nb_remain;
	irqflags_t flags;

	flags = cpu_irq_save();
	udd_disable_in_send_interrupt(0);
8000263e:	30 1a       	mov	r10,1
80002640:	fe 69 12 20 	mov	r9,-126432
80002644:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002646:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
8000264a:	4b 68       	lddpc	r8,80002720 <udd_ctrl_in_sent+0xec>
8000264c:	70 08       	ld.w	r8,r8[0x0]
8000264e:	58 38       	cp.w	r8,3
80002650:	c0 71       	brne	8000265e <udd_ctrl_in_sent+0x2a>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
80002652:	f0 1f 00 35 	mcall	80002724 <udd_ctrl_in_sent+0xf0>
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002656:	f0 1f 00 35 	mcall	80002728 <udd_ctrl_in_sent+0xf4>
		return;
8000265a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
8000265e:	4b 48       	lddpc	r8,8000272c <udd_ctrl_in_sent+0xf8>
80002660:	90 08       	ld.sh	r8,r8[0x0]
80002662:	4b 49       	lddpc	r9,80002730 <udd_ctrl_in_sent+0xfc>
80002664:	92 67       	ld.sh	r7,r9[0xc]
80002666:	10 17       	sub	r7,r8
80002668:	5c 87       	casts.h	r7
	if (0 == nb_remain) {
8000266a:	c2 91       	brne	800026bc <udd_ctrl_in_sent+0x88>
		// All content of current buffer payload are sent
		// Update number of total data sending by previous playlaod buffer
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
8000266c:	4b 2a       	lddpc	r10,80002734 <udd_ctrl_in_sent+0x100>
8000266e:	94 09       	ld.sh	r9,r10[0x0]
80002670:	10 09       	add	r9,r8
80002672:	b4 09       	st.h	r10[0x0],r9
		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans)
80002674:	4a fa       	lddpc	r10,80002730 <udd_ctrl_in_sent+0xfc>
80002676:	94 3a       	ld.sh	r10,r10[0x6]
80002678:	f2 0a 19 00 	cp.h	r10,r9
8000267c:	c0 40       	breq	80002684 <udd_ctrl_in_sent+0x50>
8000267e:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80002682:	c1 20       	breq	800026a6 <udd_ctrl_in_sent+0x72>

static void udd_ctrl_send_zlp_out(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
80002684:	30 49       	mov	r9,4
80002686:	4a 78       	lddpc	r8,80002720 <udd_ctrl_in_sent+0xec>
80002688:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000268a:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
8000268e:	d3 03       	ssrf	0x10

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
	udd_ack_nak_in(0);
80002690:	31 08       	mov	r8,16
80002692:	fe 6a 11 60 	mov	r10,-126624
80002696:	95 08       	st.w	r10[0x0],r8
	udd_enable_nak_in_interrupt(0);
80002698:	fe 6a 11 f0 	mov	r10,-126480
8000269c:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000269e:	e3 b9 00 00 	mtsr	0x0,r9
				|| (udd_ctrl_payload_nb_trans%USB_DEVICE_EP_CTRL_SIZE)) {
			// All data requested are transfered or a short packet has been sent
			// then it is the end of data phase.
			// Generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
800026a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		}
		// Need of new buffer because the data phase is not complete
		if ((!udd_g_ctrlreq.over_under_run)
800026a6:	4a 38       	lddpc	r8,80002730 <udd_ctrl_in_sent+0xfc>
800026a8:	70 5c       	ld.w	r12,r8[0x14]
800026aa:	58 0c       	cp.w	r12,0
800026ac:	c0 80       	breq	800026bc <udd_ctrl_in_sent+0x88>
800026ae:	5d 1c       	icall	r12
800026b0:	c0 60       	breq	800026bc <udd_ctrl_in_sent+0x88>
				|| (!udd_g_ctrlreq.over_under_run())) {
			// Underrun then send zlp on IN
			// Here nb_remain=0, this allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			udd_ctrl_payload_nb_trans = 0;
800026b2:	30 09       	mov	r9,0
800026b4:	49 e8       	lddpc	r8,8000272c <udd_ctrl_in_sent+0xf8>
800026b6:	b0 09       	st.h	r8[0x0],r9
			nb_remain = udd_g_ctrlreq.payload_size;
800026b8:	49 e8       	lddpc	r8,80002730 <udd_ctrl_in_sent+0xfc>
800026ba:	90 67       	ld.sh	r7,r8[0xc]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026bc:	e1 b5 00 00 	mfsr	r5,0x0
	cpu_irq_disable();
800026c0:	d3 03       	ssrf	0x10
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write
	// and if no OUT ZLP is recevied the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
800026c2:	fe 68 11 30 	mov	r8,-126672
800026c6:	70 08       	ld.w	r8,r8[0x0]
800026c8:	e2 18 00 02 	andl	r8,0x2,COH
800026cc:	c0 80       	breq	800026dc <udd_ctrl_in_sent+0xa8>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800026ce:	e3 b5 00 00 	mtsr	0x0,r5
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
800026d2:	30 49       	mov	r9,4
800026d4:	49 38       	lddpc	r8,80002720 <udd_ctrl_in_sent+0xec>
800026d6:	91 09       	st.w	r8[0x0],r9
		return; // Exit of IN DATA phase
800026d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800026dc:	34 08       	mov	r8,64
800026de:	f0 07 19 00 	cp.h	r7,r8
800026e2:	f9 b7 0b 40 	movhi	r7,64
	}
	// Write quickly the IN data
	memcpy(udd_ctrl_buffer,
800026e6:	49 26       	lddpc	r6,8000272c <udd_ctrl_in_sent+0xf8>
800026e8:	8c 88       	ld.uh	r8,r6[0x0]
800026ea:	49 29       	lddpc	r9,80002730 <udd_ctrl_in_sent+0xfc>
800026ec:	72 2b       	ld.w	r11,r9[0x8]
800026ee:	0e 9a       	mov	r10,r7
800026f0:	5c 7a       	castu.h	r10
800026f2:	10 0b       	add	r11,r8
800026f4:	49 1c       	lddpc	r12,80002738 <udd_ctrl_in_sent+0x104>
800026f6:	f0 1f 00 12 	mcall	8000273c <udd_ctrl_in_sent+0x108>
			udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans,
			nb_remain);
	udd_ctrl_payload_nb_trans += nb_remain;
800026fa:	8c 08       	ld.sh	r8,r6[0x0]
800026fc:	0e 08       	add	r8,r7
800026fe:	ac 08       	st.h	r6[0x0],r8
	udd_udesc_set_buf0_ctn(0, nb_remain);
80002700:	49 08       	lddpc	r8,80002740 <udd_ctrl_in_sent+0x10c>
80002702:	70 19       	ld.w	r9,r8[0x4]
80002704:	f3 d7 d0 0f 	bfins	r9,r7,0x0,0xf
80002708:	91 19       	st.w	r8[0x4],r9

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
8000270a:	30 18       	mov	r8,1
8000270c:	fe 69 11 60 	mov	r9,-126624
80002710:	93 08       	st.w	r9[0x0],r8
	udd_enable_in_send_interrupt(0);
80002712:	fe 69 11 f0 	mov	r9,-126480
80002716:	93 08       	st.w	r9[0x0],r8
80002718:	e3 b5 00 00 	mtsr	0x0,r5
#endif
	barrier();
8000271c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002720:	00 00       	add	r0,r0
80002722:	03 64       	ld.uh	r4,--r1
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	24 74       	sub	r4,71
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	24 34       	sub	r4,67
8000272c:	00 00       	add	r0,r0
8000272e:	03 62       	ld.uh	r2,--r1
80002730:	00 00       	add	r0,r0
80002732:	05 7c       	ld.ub	r12,--r2
80002734:	00 00       	add	r0,r0
80002736:	02 88       	andn	r8,r1
80002738:	00 00       	add	r0,r0
8000273a:	05 94       	ld.ub	r4,r2[0x1]
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	42 7a       	lddsp	r10,sp[0x9c]
80002740:	00 00       	add	r0,r0
80002742:	02 e0       	st.h	--r1,r0

80002744 <udd_ep_trans_done>:
//--- INTERNAL ROUTINES TO MANAGED THE BULK/INTERRUPT/ISOCHRONOUS ENDPOINTS

#if (0!=USB_DEVICE_MAX_EP)

static void udd_ep_trans_done(udd_ep_id_t ep, bool b_abort)
{
80002744:	d4 31       	pushm	r0-r7,lr
80002746:	20 1d       	sub	sp,4
80002748:	16 95       	mov	r5,r11
	uint16_t ep_size, nb_trans;
	uint16_t next_trans;
	udd_ep_id_t ep_num;
	irqflags_t flags;

	ep_num = ep & USB_EP_ADDR_MASK;
8000274a:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
	ep_size = udd_get_endpoint_size(ep_num);
8000274e:	f0 00 15 02 	lsl	r0,r8,0x2
80002752:	fe 6a 11 00 	mov	r10,-126720
80002756:	e0 0a 00 09 	add	r9,r0,r10
8000275a:	72 01       	ld.w	r1,r9[0x0]

	// Get job corresponding at endpoint
	ptr_job = &udd_ep_job[ep_num - 1];
8000275c:	f0 c6 00 01 	sub	r6,r8,1
80002760:	ec 06 00 27 	add	r7,r6,r6<<0x2
80002764:	fe f9 02 bc 	ld.w	r9,pc[700]
80002768:	f2 07 00 27 	add	r7,r9,r7<<0x2

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000276c:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002770:	d3 03       	ssrf	0x10

	// Disable interrupt of endpoint
	flags = cpu_irq_save();
	udd_disable_endpoint_interrupt(ep_num);
80002772:	e0 64 10 00 	mov	r4,4096
80002776:	e8 08 09 44 	lsl	r4,r4,r8
8000277a:	fe 6a 10 00 	mov	r10,-126976
8000277e:	95 54       	st.w	r10[0x14],r4
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002780:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);

	if (!ptr_job->busy) {
80002784:	6e 09       	ld.w	r9,r7[0x0]
80002786:	58 09       	cp.w	r9,0
80002788:	e0 84 01 4a 	brge	80002a1c <udd_ep_trans_done+0x2d8>
	uint16_t next_trans;
	udd_ep_id_t ep_num;
	irqflags_t flags;

	ep_num = ep & USB_EP_ADDR_MASK;
	ep_size = udd_get_endpoint_size(ep_num);
8000278c:	e3 d1 c0 83 	bfextu	r1,r1,0x4,0x3
80002790:	30 89       	mov	r9,8
80002792:	f2 01 09 41 	lsl	r1,r9,r1
80002796:	5c 81       	casts.h	r1

	if (!ptr_job->busy) {
		return; // No job is running, then ignore it (system error)
	}

	if (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN)) {
80002798:	30 09       	mov	r9,0
8000279a:	f2 0c 18 00 	cp.b	r12,r9
8000279e:	e0 84 00 90 	brge	800028be <udd_ep_trans_done+0x17a>
		// Transfer complete on IN
		nb_trans = udd_udesc_get_buf0_size(ep_num);
800027a2:	f0 0a 15 01 	lsl	r10,r8,0x1
800027a6:	a3 78       	lsl	r8,0x3
800027a8:	2f f8       	sub	r8,-1
800027aa:	fe f9 02 7a 	ld.w	r9,pc[634]
800027ae:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
800027b2:	f3 d9 c2 0f 	bfextu	r9,r9,0x10,0xf

		// Lock emission of new IN packet
		udd_enable_busy_bank0(ep_num);
800027b6:	fe 68 11 f0 	mov	r8,-126480
800027ba:	e0 08 00 0b 	add	r11,r0,r8
800027be:	fc 18 01 00 	movh	r8,0x100
800027c2:	97 08       	st.w	r11[0x0],r8

		// Ack interrupt
		udd_ack_in_send(ep_num);
800027c4:	fe 6c 11 60 	mov	r12,-126624
800027c8:	e0 0c 00 08 	add	r8,r0,r12
800027cc:	30 1c       	mov	r12,1
800027ce:	91 0c       	st.w	r8[0x0],r12
		udd_ack_fifocon(ep_num);
800027d0:	fe 68 12 20 	mov	r8,-126432
800027d4:	e0 08 00 0c 	add	r12,r0,r8
800027d8:	e0 68 40 00 	mov	r8,16384
800027dc:	99 08       	st.w	r12[0x0],r8

		if (0 == nb_trans) {
800027de:	58 09       	cp.w	r9,0
800027e0:	c1 01       	brne	80002800 <udd_ep_trans_done+0xbc>
			if (0 == udd_nb_busy_bank(ep_num)) {
800027e2:	e0 30 ee d0 	sub	r0,126672
800027e6:	60 08       	ld.w	r8,r0[0x0]
800027e8:	f1 d8 c1 82 	bfextu	r8,r8,0xc,0x2
800027ec:	c0 a1       	brne	80002800 <udd_ep_trans_done+0xbc>
				// All byte are transfered than take nb byte requested
				nb_trans = udd_udesc_get_buf0_ctn(ep_num);
800027ee:	f4 09 15 02 	lsl	r9,r10,0x2
800027f2:	2f f9       	sub	r9,-1
800027f4:	fe f8 02 30 	ld.w	r8,pc[560]
800027f8:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800027fc:	f3 d9 c0 0f 	bfextu	r9,r9,0x0,0xf
			}
		}
		// Update number of data transfered
		ptr_job->nb_trans += nb_trans;
80002800:	6e 38       	ld.w	r8,r7[0xc]
80002802:	10 09       	add	r9,r8
80002804:	8f 39       	st.w	r7[0xc],r9

		// Need to send other data
		if ((ptr_job->nb_trans != ptr_job->buf_size)
80002806:	6e 28       	ld.w	r8,r7[0x8]
80002808:	10 39       	cp.w	r9,r8
8000280a:	c0 61       	brne	80002816 <udd_ep_trans_done+0xd2>
				|| ptr_job->b_shortpacket) {
8000280c:	6e 06       	ld.w	r6,r7[0x0]
8000280e:	e6 16 40 00 	andh	r6,0x4000,COH
80002812:	e0 80 00 fa 	breq	80002a06 <udd_ep_trans_done+0x2c2>
			next_trans = ptr_job->buf_size - ptr_job->nb_trans;
80002816:	f0 09 01 09 	sub	r9,r8,r9
8000281a:	ed d9 b0 10 	bfexts	r6,r9,0x0,0x10
			if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
8000281e:	30 08       	mov	r8,0
80002820:	f0 06 19 00 	cp.h	r6,r8
80002824:	c1 64       	brge	80002850 <udd_ep_trans_done+0x10c>
				// The USB hardware support a maximum
				// transfer size of UDD_ENDPOINT_MAX_TRANS Bytes
				next_trans = UDD_ENDPOINT_MAX_TRANS -
80002826:	5c 71       	castu.h	r1
80002828:	e0 68 7f ff 	mov	r8,32767
8000282c:	f0 01 0c 00 	divs	r0,r8,r1
80002830:	e0 66 7f ff 	mov	r6,32767
80002834:	02 16       	sub	r6,r1
80002836:	5c 86       	casts.h	r6
						(UDD_ENDPOINT_MAX_TRANS % ep_size);
				udd_udesc_set_buf0_autozlp(ep_num, false);
80002838:	4f b8       	lddpc	r8,80002a24 <udd_ep_trans_done+0x2e0>
8000283a:	f4 09 15 02 	lsl	r9,r10,0x2
8000283e:	2f f9       	sub	r9,-1
80002840:	f0 09 03 25 	ld.w	r5,r8[r9<<0x2]
80002844:	30 03       	mov	r3,0
80002846:	eb d3 d3 e1 	bfins	r5,r3,0x1f,0x1
8000284a:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000284e:	c1 28       	rjmp	80002872 <udd_ep_trans_done+0x12e>
			} else {
				// Need ZLP, if requested and last packet is not a short packet
				udd_udesc_set_buf0_autozlp(ep_num, ptr_job->b_shortpacket);
80002850:	6e 08       	ld.w	r8,r7[0x0]
80002852:	e5 d8 c3 c1 	bfextu	r2,r8,0x1e,0x1
80002856:	4f 49       	lddpc	r9,80002a24 <udd_ep_trans_done+0x2e0>
80002858:	f4 05 15 02 	lsl	r5,r10,0x2
8000285c:	2f f5       	sub	r5,-1
8000285e:	f2 05 03 23 	ld.w	r3,r9[r5<<0x2]
80002862:	e7 d2 d3 e1 	bfins	r3,r2,0x1f,0x1
80002866:	f2 05 09 23 	st.w	r9[r5<<0x2],r3
				ptr_job->b_shortpacket = false; // No need to request another ZLP
8000286a:	30 09       	mov	r9,0
8000286c:	f1 d9 d3 c1 	bfins	r8,r9,0x1e,0x1
80002870:	8f 08       	st.w	r7[0x0],r8
			}

			udd_udesc_set_buf0_ctn(ep_num, next_trans);
80002872:	4e d8       	lddpc	r8,80002a24 <udd_ep_trans_done+0x2e0>
80002874:	f4 09 15 02 	lsl	r9,r10,0x2
80002878:	2f f9       	sub	r9,-1
8000287a:	f0 09 03 25 	ld.w	r5,r8[r9<<0x2]
8000287e:	eb d6 d0 0f 	bfins	r5,r6,0x0,0xf
80002882:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
			udd_udesc_rst_buf0_size(ep_num);
80002886:	f0 09 03 26 	ld.w	r6,r8[r9<<0x2]
8000288a:	30 05       	mov	r5,0
8000288c:	ed d5 d2 0f 	bfins	r6,r5,0x10,0xf
80002890:	f0 09 09 26 	st.w	r8[r9<<0x2],r6

			// Link the user buffer directly on USB hardware DMA
			udd_udesc_set_buf0_addr(ep_num, &ptr_job->buf[ptr_job->nb_trans]);
80002894:	6e 16       	ld.w	r6,r7[0x4]
80002896:	6e 39       	ld.w	r9,r7[0xc]
80002898:	ec 09 00 09 	add	r9,r6,r9
8000289c:	a5 6a       	lsl	r10,0x4
8000289e:	14 08       	add	r8,r10
800028a0:	91 09       	st.w	r8[0x0],r9

			// Start transfer
			udd_disable_busy_bank0(ep_num);
800028a2:	fc 18 01 00 	movh	r8,0x100
800028a6:	99 08       	st.w	r12[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800028a8:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800028ac:	d3 03       	ssrf	0x10

			// Enable interrupt
			flags = cpu_irq_save();
			udd_enable_in_send_interrupt(ep_num);
800028ae:	30 19       	mov	r9,1
800028b0:	97 09       	st.w	r11[0x0],r9
			udd_enable_endpoint_interrupt(ep_num);
800028b2:	fe 69 10 00 	mov	r9,-126976
800028b6:	93 64       	st.w	r9[0x18],r4
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800028b8:	e3 b8 00 00 	mtsr	0x0,r8
#endif
	barrier();
800028bc:	cb 08       	rjmp	80002a1c <udd_ep_trans_done+0x2d8>
		}
	}
	else
	{
		// Transfer complete on OUT
		nb_trans = udd_udesc_get_buf0_ctn(ep_num);
800028be:	f0 02 15 01 	lsl	r2,r8,0x1
800028c2:	a3 78       	lsl	r8,0x3
800028c4:	2f f8       	sub	r8,-1
800028c6:	4d 89       	lddpc	r9,80002a24 <udd_ep_trans_done+0x2e0>
800028c8:	f2 08 03 23 	ld.w	r3,r9[r8<<0x2]
800028cc:	e7 d3 c0 0f 	bfextu	r3,r3,0x0,0xf

		// Lock reception of new OUT packet
		udd_enable_busy_bank0(ep_num);
800028d0:	fe 6c 11 f0 	mov	r12,-126480
800028d4:	e0 0c 00 0c 	add	r12,r0,r12
800028d8:	50 0c       	stdsp	sp[0x0],r12
800028da:	fc 18 01 00 	movh	r8,0x100
800028de:	99 08       	st.w	r12[0x0],r8

		// Ack interrupt
		udd_ack_out_received(ep_num);
800028e0:	fe 6a 11 60 	mov	r10,-126624
800028e4:	e0 0a 00 08 	add	r8,r0,r10
800028e8:	30 29       	mov	r9,2
800028ea:	91 09       	st.w	r8[0x0],r9
		udd_ack_fifocon(ep_num);
800028ec:	e0 30 ed e0 	sub	r0,126432
800028f0:	e0 68 40 00 	mov	r8,16384
800028f4:	81 08       	st.w	r0[0x0],r8

		// Can be necessary to copy data receiv from cache buffer to user buffer
		if (ptr_job->b_use_out_cache_buffer) {
800028f6:	6e 08       	ld.w	r8,r7[0x0]
800028f8:	e6 18 20 00 	andh	r8,0x2000,COH
800028fc:	c1 00       	breq	8000291c <udd_ep_trans_done+0x1d8>
			memcpy(&ptr_job->buf[ptr_job->nb_trans],
800028fe:	6e 1c       	ld.w	r12,r7[0x4]
80002900:	6e 39       	ld.w	r9,r7[0xc]
80002902:	f7 d1 c0 10 	bfextu	r11,r1,0x0,0x10
80002906:	6e 28       	ld.w	r8,r7[0x8]
80002908:	f0 0b 0d 0a 	divu	r10,r8,r11
8000290c:	ec 08 15 06 	lsl	r8,r6,0x6
80002910:	16 9a       	mov	r10,r11
80002912:	4c 6b       	lddpc	r11,80002a28 <udd_ep_trans_done+0x2e4>
80002914:	10 0b       	add	r11,r8
80002916:	12 0c       	add	r12,r9
80002918:	f0 1f 00 45 	mcall	80002a2c <udd_ep_trans_done+0x2e8>
					udd_ep_out_cache_buffer[ep_num - 1],
					ptr_job->buf_size % ep_size);
		}

		// Update number of data transfered
		ptr_job->nb_trans += nb_trans;
8000291c:	6e 38       	ld.w	r8,r7[0xc]
8000291e:	e6 08 00 08 	add	r8,r3,r8
80002922:	8f 38       	st.w	r7[0xc],r8
		if (ptr_job->nb_trans > ptr_job->buf_size) {
80002924:	6e 29       	ld.w	r9,r7[0x8]
			ptr_job->nb_trans = ptr_job->buf_size;
80002926:	12 38       	cp.w	r8,r9
80002928:	ef f9 ba 03 	st.whi	r7[0xc],r9
		}

		// If all previous data requested are received and user buffer not full
		// then need to receiv other data
		if ((nb_trans == udd_udesc_get_buf0_size(ep_num))
8000292c:	e4 09 15 02 	lsl	r9,r2,0x2
80002930:	2f f9       	sub	r9,-1
80002932:	4b d8       	lddpc	r8,80002a24 <udd_ep_trans_done+0x2e0>
80002934:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80002938:	f1 d8 c2 0f 	bfextu	r8,r8,0x10,0xf
8000293c:	e6 08 19 00 	cp.h	r8,r3
80002940:	c6 31       	brne	80002a06 <udd_ep_trans_done+0x2c2>
			&& (ptr_job->nb_trans != ptr_job->buf_size)) {
80002942:	6e 38       	ld.w	r8,r7[0xc]
80002944:	6e 29       	ld.w	r9,r7[0x8]
			ptr_job->nb_trans = ptr_job->buf_size;
		}

		// If all previous data requested are received and user buffer not full
		// then need to receiv other data
		if ((nb_trans == udd_udesc_get_buf0_size(ep_num))
80002946:	12 38       	cp.w	r8,r9
80002948:	c5 f0       	breq	80002a06 <udd_ep_trans_done+0x2c2>
			&& (ptr_job->nb_trans != ptr_job->buf_size)) {
			next_trans = ptr_job->buf_size - ptr_job->nb_trans;
8000294a:	f2 08 01 08 	sub	r8,r9,r8
8000294e:	5c 88       	casts.h	r8
			if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
80002950:	30 09       	mov	r9,0
80002952:	f2 08 19 00 	cp.h	r8,r9
80002956:	c0 c4       	brge	8000296e <udd_ep_trans_done+0x22a>
				// The USB hardware support a maximum transfer size
				// of UDD_ENDPOINT_MAX_TRANS Bytes
				next_trans = UDD_ENDPOINT_MAX_TRANS
80002958:	f3 d1 c0 10 	bfextu	r9,r1,0x0,0x10
8000295c:	e0 68 7f ff 	mov	r8,32767
80002960:	f0 09 0c 08 	divs	r8,r8,r9
80002964:	e0 68 7f ff 	mov	r8,32767
80002968:	12 18       	sub	r8,r9
8000296a:	5c 88       	casts.h	r8
8000296c:	c0 98       	rjmp	8000297e <udd_ep_trans_done+0x23a>
						- (UDD_ENDPOINT_MAX_TRANS % ep_size);
			} else {
				next_trans -= next_trans % ep_size;
8000296e:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80002972:	f7 d1 c0 10 	bfextu	r11,r1,0x0,0x10
80002976:	f2 0b 0d 0a 	divu	r10,r9,r11
8000297a:	16 18       	sub	r8,r11
8000297c:	5c 88       	casts.h	r8
			}

			udd_udesc_rst_buf0_ctn(ep_num);
8000297e:	4a a9       	lddpc	r9,80002a24 <udd_ep_trans_done+0x2e0>
80002980:	e4 0a 15 02 	lsl	r10,r2,0x2
80002984:	2f fa       	sub	r10,-1
80002986:	f2 0a 03 2b 	ld.w	r11,r9[r10<<0x2]
8000298a:	30 0c       	mov	r12,0
8000298c:	f7 dc d0 0f 	bfins	r11,r12,0x0,0xf
80002990:	f2 0a 09 2b 	st.w	r9[r10<<0x2],r11
			if (next_trans < ep_size) {
80002994:	e2 08 19 00 	cp.h	r8,r1
80002998:	c1 72       	brcc	800029c6 <udd_ep_trans_done+0x282>
				// Use the cache buffer for Bulk or Interrupt size endpoint
				ptr_job->b_use_out_cache_buffer = true;
8000299a:	6e 08       	ld.w	r8,r7[0x0]
8000299c:	30 19       	mov	r9,1
8000299e:	f1 d9 d3 a1 	bfins	r8,r9,0x1d,0x1
800029a2:	8f 08       	st.w	r7[0x0],r8
				udd_udesc_set_buf0_addr(ep_num,
800029a4:	a7 66       	lsl	r6,0x6
800029a6:	4a 18       	lddpc	r8,80002a28 <udd_ep_trans_done+0x2e4>
800029a8:	10 06       	add	r6,r8
800029aa:	49 f8       	lddpc	r8,80002a24 <udd_ep_trans_done+0x2e0>
800029ac:	e4 09 15 04 	lsl	r9,r2,0x4
800029b0:	f0 09 00 09 	add	r9,r8,r9
800029b4:	93 06       	st.w	r9[0x0],r6
						udd_ep_out_cache_buffer[ep_num-1]);
				udd_udesc_set_buf0_size(ep_num, ep_size);
800029b6:	14 92       	mov	r2,r10
800029b8:	f0 0a 03 29 	ld.w	r9,r8[r10<<0x2]
800029bc:	f3 d1 d2 0f 	bfins	r9,r1,0x10,0xf
800029c0:	f0 0a 09 29 	st.w	r8[r10<<0x2],r9
800029c4:	c1 28       	rjmp	800029e8 <udd_ep_trans_done+0x2a4>
			} else {
				// Link the user buffer directly on USB hardware DMA
				udd_udesc_set_buf0_addr(ep_num, &ptr_job->buf[ptr_job->nb_trans]);
800029c6:	6e 1b       	ld.w	r11,r7[0x4]
800029c8:	6e 39       	ld.w	r9,r7[0xc]
800029ca:	12 0b       	add	r11,r9
800029cc:	49 69       	lddpc	r9,80002a24 <udd_ep_trans_done+0x2e0>
800029ce:	e4 0a 15 04 	lsl	r10,r2,0x4
800029d2:	f2 0a 00 0a 	add	r10,r9,r10
800029d6:	95 0b       	st.w	r10[0x0],r11
				udd_udesc_set_buf0_size(ep_num, next_trans);
800029d8:	a3 62       	lsl	r2,0x2
800029da:	2f f2       	sub	r2,-1
800029dc:	f2 02 03 2a 	ld.w	r10,r9[r2<<0x2]
800029e0:	f5 d8 d2 0f 	bfins	r10,r8,0x10,0xf
800029e4:	f2 02 09 2a 	st.w	r9[r2<<0x2],r10
			}
			// Start transfer
			udd_disable_busy_bank0(ep_num);
800029e8:	fc 18 01 00 	movh	r8,0x100
800029ec:	81 08       	st.w	r0[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800029ee:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800029f2:	d3 03       	ssrf	0x10

			// Enable interrupt
			flags = cpu_irq_save();
			udd_enable_out_received_interrupt(ep_num);
800029f4:	30 29       	mov	r9,2
800029f6:	40 0c       	lddsp	r12,sp[0x0]
800029f8:	99 09       	st.w	r12[0x0],r9
			udd_enable_endpoint_interrupt(ep_num);
800029fa:	fe 69 10 00 	mov	r9,-126976
800029fe:	93 64       	st.w	r9[0x18],r4
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002a00:	e3 b8 00 00 	mtsr	0x0,r8
#endif
	barrier();
80002a04:	c0 c8       	rjmp	80002a1c <udd_ep_trans_done+0x2d8>
			return;
		}
	}

	// Job complete then call callback
	ptr_job->busy = false;
80002a06:	6e 08       	ld.w	r8,r7[0x0]
80002a08:	30 09       	mov	r9,0
80002a0a:	f1 d9 d3 e1 	bfins	r8,r9,0x1f,0x1
80002a0e:	8f 08       	st.w	r7[0x0],r8
	if (NULL != ptr_job->call_trans) {
80002a10:	6e 48       	ld.w	r8,r7[0x10]
80002a12:	58 08       	cp.w	r8,0
80002a14:	c0 40       	breq	80002a1c <udd_ep_trans_done+0x2d8>
		ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
80002a16:	6e 3b       	ld.w	r11,r7[0xc]
80002a18:	0a 9c       	mov	r12,r5
80002a1a:	5d 18       	icall	r8
				UDD_EP_TRANSFER_OK, ptr_job->nb_trans);
	}
	return;
}
80002a1c:	2f fd       	sub	sp,-4
80002a1e:	d8 32       	popm	r0-r7,pc
80002a20:	00 00       	add	r0,r0
80002a22:	02 8c       	andn	r12,r1
80002a24:	00 00       	add	r0,r0
80002a26:	02 e0       	st.h	--r1,r0
80002a28:	00 00       	add	r0,r0
80002a2a:	04 bc       	st.h	r2++,r12
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	42 7a       	lddsp	r10,sp[0x9c]

80002a30 <udd_ep_abort>:
	return true;
}


void udd_ep_abort(udd_ep_id_t ep)
{
80002a30:	d4 01       	pushm	lr
	ep &= USB_EP_ADDR_MASK;
80002a32:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

	// Stop transfer
	udd_enable_busy_bank0(ep);
80002a36:	f8 08 15 02 	lsl	r8,r12,0x2
80002a3a:	e0 38 ee 10 	sub	r8,126480
80002a3e:	fc 19 01 00 	movh	r9,0x100
80002a42:	91 09       	st.w	r8[0x0],r9

	// Abort job on endpoint
	udd_ep_trans_done(ep, true);
80002a44:	30 1b       	mov	r11,1
80002a46:	f0 1f 00 02 	mcall	80002a4c <udd_ep_abort+0x1c>
}
80002a4a:	d8 02       	popm	pc
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	27 44       	sub	r4,116

80002a50 <udd_ep_set_halt>:
	return Is_udd_endpoint_stall_requested(ep & USB_EP_ADDR_MASK);
}


bool udd_ep_set_halt(udd_ep_id_t ep)
{
80002a50:	d4 01       	pushm	lr
	uint8_t index = ep & USB_EP_ADDR_MASK;
80002a52:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4

	if (USB_DEVICE_MAX_EP < index) {
80002a56:	30 39       	mov	r9,3
80002a58:	f2 08 18 00 	cp.b	r8,r9
80002a5c:	e0 88 00 03 	brls	80002a62 <udd_ep_set_halt+0x12>
80002a60:	d8 0a       	popm	pc,r12=0
		return false;
	}

	// Stall endpoint
	udd_enable_stall_handshake(index);
80002a62:	a3 68       	lsl	r8,0x2
80002a64:	e0 38 ee 10 	sub	r8,126480
80002a68:	e8 69 00 00 	mov	r9,524288
80002a6c:	91 09       	st.w	r8[0x0],r9
	udd_reset_data_toggle(index);
80002a6e:	e4 69 00 00 	mov	r9,262144
80002a72:	91 09       	st.w	r8[0x0],r9
	udd_ep_abort(ep);
80002a74:	f0 1f 00 02 	mcall	80002a7c <udd_ep_set_halt+0x2c>
80002a78:	da 0a       	popm	pc,r12=1
80002a7a:	00 00       	add	r0,r0
80002a7c:	80 00       	ld.sh	r0,r0[0x0]
80002a7e:	2a 30       	sub	r0,-93

80002a80 <udd_ep_free>:
	return true;
}


void udd_ep_free(udd_ep_id_t ep)
{
80002a80:	eb cd 40 80 	pushm	r7,lr
80002a84:	18 97       	mov	r7,r12
	udd_ep_abort(ep);
80002a86:	f0 1f 00 07 	mcall	80002aa0 <udd_ep_free+0x20>
#if( defined UDC_RAM_ACCESS_ERROR_EVENT )
	if( Is_udd_ram_access_error(ep & 0x7F) ){
		UDC_RAM_ACCESS_ERROR_EVENT();
	}
#endif
	udd_disable_endpoint(ep & 0x7F);
80002a8a:	fe 68 10 00 	mov	r8,-126976
80002a8e:	70 79       	ld.w	r9,r8[0x1c]
80002a90:	30 1a       	mov	r10,1
80002a92:	f4 07 09 47 	lsl	r7,r10,r7
80002a96:	5c d7       	com	r7
80002a98:	12 67       	and	r7,r9
80002a9a:	91 77       	st.w	r8[0x1c],r7
}
80002a9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	2a 30       	sub	r0,-93

80002aa4 <udd_interrupt>:
void udd_interrupt(void); // To avoid GCC warning
void udd_interrupt(void)
#else
ISR(udd_interrupt, AVR32_USBC_IRQ_GROUP, UDD_USB_INT_LEVEL)
#endif
{
80002aa4:	eb cd 40 80 	pushm	r7,lr
	if (Is_udd_sof()) {
80002aa8:	fe 68 10 04 	mov	r8,-126972
80002aac:	70 08       	ld.w	r8,r8[0x0]
80002aae:	e2 18 00 04 	andl	r8,0x4,COH
80002ab2:	c0 90       	breq	80002ac4 <udd_interrupt+0x20>
		udd_ack_sof();
80002ab4:	30 49       	mov	r9,4
80002ab6:	fe 68 10 08 	mov	r8,-126968
80002aba:	91 09       	st.w	r8[0x0],r9
		udc_sof_notify();
80002abc:	f0 1f 01 24 	mcall	80002f4c <udd_interrupt+0x4a8>
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_end;
80002ac0:	e0 8f 02 36 	bral	80002f2c <udd_interrupt+0x488>


static bool udd_ctrl_interrupt(void)
{

	if (!Is_udd_endpoint_interrupt(0)) {
80002ac4:	fe 68 10 00 	mov	r8,-126976
80002ac8:	70 18       	ld.w	r8,r8[0x4]
80002aca:	e2 18 10 00 	andl	r8,0x1000,COH
80002ace:	e0 80 01 6c 	breq	80002da6 <udd_interrupt+0x302>
		return false; // No interrupt events on control endpoint
	}

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
80002ad2:	fe 68 12 20 	mov	r8,-126432
80002ad6:	31 09       	mov	r9,16
80002ad8:	91 09       	st.w	r8[0x0],r9
	udd_disable_nak_out_interrupt(0);
80002ada:	30 89       	mov	r9,8
80002adc:	91 09       	st.w	r8[0x0],r9

	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
80002ade:	fe 68 11 30 	mov	r8,-126672
80002ae2:	70 08       	ld.w	r8,r8[0x0]
80002ae4:	e2 18 00 04 	andl	r8,0x4,COH
80002ae8:	c7 30       	breq	80002bce <udd_interrupt+0x12a>

static void udd_ctrl_setup_received(void)
{
	irqflags_t flags;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
80002aea:	fe f8 04 66 	ld.w	r8,pc[1126]
80002aee:	70 08       	ld.w	r8,r8[0x0]
80002af0:	58 08       	cp.w	r8,0
80002af2:	c0 50       	breq	80002afc <udd_interrupt+0x58>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
80002af4:	f0 1f 01 18 	mcall	80002f54 <udd_interrupt+0x4b0>

		// Reinitializes control endpoint management
		udd_ctrl_init();
80002af8:	f0 1f 01 18 	mcall	80002f58 <udd_interrupt+0x4b4>
	}
	// Fill setup request structure
	if (8 != udd_udesc_get_buf0_ctn(0)) {
80002afc:	fe f8 04 60 	ld.w	r8,pc[1120]
80002b00:	70 18       	ld.w	r8,r8[0x4]
80002b02:	f1 d8 c0 0f 	bfextu	r8,r8,0x0,0xf
80002b06:	58 88       	cp.w	r8,8
80002b08:	c0 90       	breq	80002b1a <udd_interrupt+0x76>
		udd_ctrl_stall_data();
80002b0a:	f0 1f 01 16 	mcall	80002f60 <udd_interrupt+0x4bc>
		udd_ack_setup_received(0);
80002b0e:	30 49       	mov	r9,4
80002b10:	fe 68 11 60 	mov	r8,-126624
80002b14:	91 09       	st.w	r8[0x0],r9
80002b16:	e0 8f 02 0b 	bral	80002f2c <udd_interrupt+0x488>
		return; // Error data number doesn't correspond to SETUP packet
	}
	memcpy((uint8_t *) & udd_g_ctrlreq.req, udd_ctrl_buffer, 8);
80002b1a:	fe f7 04 4a 	ld.w	r7,pc[1098]
80002b1e:	30 8a       	mov	r10,8
80002b20:	fe fb 04 48 	ld.w	r11,pc[1096]
80002b24:	0e 9c       	mov	r12,r7
80002b26:	f0 1f 01 12 	mcall	80002f6c <udd_interrupt+0x4c8>

	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
80002b2a:	8e 18       	ld.sh	r8,r7[0x2]
80002b2c:	5c c8       	swap.bh	r8
80002b2e:	ae 18       	st.h	r7[0x2],r8
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
80002b30:	8e 28       	ld.sh	r8,r7[0x4]
80002b32:	5c c8       	swap.bh	r8
80002b34:	ae 28       	st.h	r7[0x4],r8
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
80002b36:	8e 38       	ld.sh	r8,r7[0x6]
80002b38:	5c c8       	swap.bh	r8
80002b3a:	ae 38       	st.h	r7[0x6],r8

	// Decode setup request
	if (udc_process_setup() == false) {
80002b3c:	f0 1f 01 0d 	mcall	80002f70 <udd_interrupt+0x4cc>
80002b40:	c0 91       	brne	80002b52 <udd_interrupt+0xae>
		// Setup request unknow then stall it
		udd_ctrl_stall_data();
80002b42:	f0 1f 01 08 	mcall	80002f60 <udd_interrupt+0x4bc>
		udd_ack_setup_received(0);
80002b46:	30 49       	mov	r9,4
80002b48:	fe 68 11 60 	mov	r8,-126624
80002b4c:	91 09       	st.w	r8[0x0],r9
80002b4e:	e0 8f 01 ef 	bral	80002f2c <udd_interrupt+0x488>
		return;
	}
	udd_ack_setup_received(0);
80002b52:	30 49       	mov	r9,4
80002b54:	fe 68 11 60 	mov	r8,-126624
80002b58:	91 09       	st.w	r8[0x0],r9

	if (Udd_setup_is_in()) {
80002b5a:	fe f8 04 0a 	ld.w	r8,pc[1034]
80002b5e:	11 89       	ld.ub	r9,r8[0x0]
80002b60:	30 08       	mov	r8,0
80002b62:	f0 09 18 00 	cp.b	r9,r8
80002b66:	c1 04       	brge	80002b86 <udd_interrupt+0xe2>
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002b68:	30 08       	mov	r8,0
80002b6a:	fe f9 04 0a 	ld.w	r9,pc[1034]
80002b6e:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002b70:	fe f9 04 08 	ld.w	r9,pc[1032]
80002b74:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
80002b76:	30 29       	mov	r9,2
80002b78:	fe f8 03 d8 	ld.w	r8,pc[984]
80002b7c:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_in_sent(); // Send first data transfer
80002b7e:	f0 1f 01 00 	mcall	80002f7c <udd_interrupt+0x4d8>
80002b82:	e0 8f 01 d5 	bral	80002f2c <udd_interrupt+0x488>
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
80002b86:	fe f8 03 de 	ld.w	r8,pc[990]
80002b8a:	90 39       	ld.sh	r9,r8[0x6]
80002b8c:	30 08       	mov	r8,0
80002b8e:	f0 09 19 00 	cp.h	r9,r8
80002b92:	c0 51       	brne	80002b9c <udd_interrupt+0xf8>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
80002b94:	f0 1f 00 fb 	mcall	80002f80 <udd_interrupt+0x4dc>
80002b98:	e0 8f 01 ca 	bral	80002f2c <udd_interrupt+0x488>
			return;
		}

		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002b9c:	30 08       	mov	r8,0
80002b9e:	fe f9 03 d6 	ld.w	r9,pc[982]
80002ba2:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002ba4:	fe f9 03 d4 	ld.w	r9,pc[980]
80002ba8:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
80002baa:	30 19       	mov	r9,1
80002bac:	fe f8 03 a4 	ld.w	r8,pc[932]
80002bb0:	91 09       	st.w	r8[0x0],r9

		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
80002bb2:	31 08       	mov	r8,16
80002bb4:	fe 69 11 60 	mov	r9,-126624
80002bb8:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002bba:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002bbe:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();
		udd_enable_nak_in_interrupt(0);
80002bc0:	fe 6a 11 f0 	mov	r10,-126480
80002bc4:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002bc6:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002bca:	e0 8f 01 b1 	bral	80002f2c <udd_interrupt+0x488>
	if (Is_udd_setup_received(0)) {
		// SETUP packet received
		udd_ctrl_setup_received();
		return true;
	}
	if (Is_udd_out_received(0)) {
80002bce:	fe 68 11 30 	mov	r8,-126672
80002bd2:	70 08       	ld.w	r8,r8[0x0]
80002bd4:	e2 18 00 02 	andl	r8,0x2,COH
80002bd8:	e0 80 00 9a 	breq	80002d0c <udd_interrupt+0x268>
static void udd_ctrl_out_received(void)
{
	irqflags_t flags;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
80002bdc:	fe f8 03 74 	ld.w	r8,pc[884]
80002be0:	70 08       	ld.w	r8,r8[0x0]
80002be2:	58 18       	cp.w	r8,1
80002be4:	c1 10       	breq	80002c06 <udd_interrupt+0x162>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state) ||
80002be6:	58 28       	cp.w	r8,2
80002be8:	5f 09       	sreq	r9
80002bea:	58 48       	cp.w	r8,4
80002bec:	5f 08       	sreq	r8
80002bee:	f3 e8 10 08 	or	r8,r9,r8
80002bf2:	c0 40       	breq	80002bfa <udd_interrupt+0x156>
				(UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quiclky,
			// - or ZLP OUT received normaly.
			udd_ctrl_endofrequest();
80002bf4:	f0 1f 00 d8 	mcall	80002f54 <udd_interrupt+0x4b0>
80002bf8:	c0 38       	rjmp	80002bfe <udd_interrupt+0x15a>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
80002bfa:	f0 1f 00 da 	mcall	80002f60 <udd_interrupt+0x4bc>
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002bfe:	f0 1f 00 d7 	mcall	80002f58 <udd_interrupt+0x4b4>
80002c02:	e0 8f 01 95 	bral	80002f2c <udd_interrupt+0x488>
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_udesc_get_buf0_ctn(0);
80002c06:	fe f8 03 56 	ld.w	r8,pc[854]
80002c0a:	70 17       	ld.w	r7,r8[0x4]
80002c0c:	ef d7 c0 0f 	bfextu	r7,r7,0x0,0xf
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
80002c10:	fe f8 03 54 	ld.w	r8,pc[852]
80002c14:	90 69       	ld.sh	r9,r8[0xc]
80002c16:	fe f8 03 62 	ld.w	r8,pc[866]
80002c1a:	90 08       	ld.sh	r8,r8[0x0]
80002c1c:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10
80002c20:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80002c24:	ee 0a 00 0a 	add	r10,r7,r10
80002c28:	14 3b       	cp.w	r11,r10
80002c2a:	c0 44       	brge	80002c32 <udd_interrupt+0x18e>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
80002c2c:	10 19       	sub	r9,r8
80002c2e:	ef d9 b0 10 	bfexts	r7,r9,0x0,0x10
				udd_ctrl_payload_nb_trans;
	}

	memcpy((uint8_t *) (udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans),
80002c32:	5c 78       	castu.h	r8
80002c34:	fe f9 03 30 	ld.w	r9,pc[816]
80002c38:	72 2c       	ld.w	r12,r9[0x8]
80002c3a:	0e 9a       	mov	r10,r7
80002c3c:	5c 7a       	castu.h	r10
80002c3e:	fe fb 03 2a 	ld.w	r11,pc[810]
80002c42:	10 0c       	add	r12,r8
80002c44:	f0 1f 00 ca 	mcall	80002f6c <udd_interrupt+0x4c8>
			udd_ctrl_buffer, nb_data);
	udd_ctrl_payload_nb_trans += nb_data;
80002c48:	fe f9 03 30 	ld.w	r9,pc[816]
80002c4c:	92 08       	ld.sh	r8,r9[0x0]
80002c4e:	0e 08       	add	r8,r7
80002c50:	5c 88       	casts.h	r8
80002c52:	b2 08       	st.h	r9[0x0],r8

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data) ||
80002c54:	34 09       	mov	r9,64
80002c56:	f2 07 19 00 	cp.h	r7,r9
80002c5a:	c0 e1       	brne	80002c76 <udd_interrupt+0x1d2>
80002c5c:	fe f9 03 08 	ld.w	r9,pc[776]
80002c60:	92 ba       	ld.uh	r10,r9[0x6]
80002c62:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80002c66:	fe f9 03 0e 	ld.w	r9,pc[782]
80002c6a:	92 89       	ld.uh	r9,r9[0x0]
80002c6c:	f6 09 00 09 	add	r9,r11,r9
80002c70:	12 3a       	cp.w	r10,r9
80002c72:	e0 89 00 18 	brgt	80002ca2 <udd_interrupt+0x1fe>
			(udd_ctrl_prev_payload_nb_trans + udd_ctrl_payload_nb_trans)))
	{
		// End of reception because it is a short packet
		// Before send ZLP, call intermediat calback
		// in case of data receiv generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
80002c76:	fe f9 02 ee 	ld.w	r9,pc[750]
80002c7a:	b2 68       	st.h	r9[0xc],r8
		if (NULL != udd_g_ctrlreq.over_under_run) {
80002c7c:	72 5c       	ld.w	r12,r9[0x14]
80002c7e:	58 0c       	cp.w	r12,0
80002c80:	c0 a0       	breq	80002c94 <udd_interrupt+0x1f0>
			if (!udd_g_ctrlreq.over_under_run()) {
80002c82:	5d 1c       	icall	r12
80002c84:	c0 81       	brne	80002c94 <udd_interrupt+0x1f0>
				// Stall ZLP
				udd_ctrl_stall_data();
80002c86:	f0 1f 00 b7 	mcall	80002f60 <udd_interrupt+0x4bc>

				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
80002c8a:	30 29       	mov	r9,2
80002c8c:	fe 68 11 60 	mov	r8,-126624
80002c90:	91 09       	st.w	r8[0x0],r9
80002c92:	c4 d9       	rjmp	80002f2c <udd_interrupt+0x488>
				return;
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
80002c94:	30 29       	mov	r9,2
80002c96:	fe 68 11 60 	mov	r8,-126624
80002c9a:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_send_zlp_in();
80002c9c:	f0 1f 00 b9 	mcall	80002f80 <udd_interrupt+0x4dc>
80002ca0:	c4 69       	rjmp	80002f2c <udd_interrupt+0x488>
		return;
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
80002ca2:	fe f9 02 c2 	ld.w	r9,pc[706]
80002ca6:	92 69       	ld.sh	r9,r9[0xc]
80002ca8:	f0 09 19 00 	cp.h	r9,r8
80002cac:	c2 11       	brne	80002cee <udd_interrupt+0x24a>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
80002cae:	fe f8 02 b6 	ld.w	r8,pc[694]
80002cb2:	70 5c       	ld.w	r12,r8[0x14]
80002cb4:	58 0c       	cp.w	r12,0
80002cb6:	c0 81       	brne	80002cc6 <udd_interrupt+0x222>
			// No callback availabled to request a new payload buffer
			udd_ctrl_stall_data();
80002cb8:	f0 1f 00 aa 	mcall	80002f60 <udd_interrupt+0x4bc>

			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002cbc:	30 29       	mov	r9,2
80002cbe:	fe 68 11 60 	mov	r8,-126624
80002cc2:	91 09       	st.w	r8[0x0],r9
80002cc4:	c3 49       	rjmp	80002f2c <udd_interrupt+0x488>
			return;
		}
		if (!udd_g_ctrlreq.over_under_run()) {
80002cc6:	5d 1c       	icall	r12
80002cc8:	c0 81       	brne	80002cd8 <udd_interrupt+0x234>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
80002cca:	f0 1f 00 a6 	mcall	80002f60 <udd_interrupt+0x4bc>

			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002cce:	30 29       	mov	r9,2
80002cd0:	fe 68 11 60 	mov	r8,-126624
80002cd4:	91 09       	st.w	r8[0x0],r9
80002cd6:	c2 b9       	rjmp	80002f2c <udd_interrupt+0x488>
			return;
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
80002cd8:	fe f9 02 9c 	ld.w	r9,pc[668]
80002cdc:	fe f8 02 9c 	ld.w	r8,pc[668]
80002ce0:	90 0b       	ld.sh	r11,r8[0x0]
80002ce2:	92 0a       	ld.sh	r10,r9[0x0]
80002ce4:	f6 0a 00 0a 	add	r10,r11,r10
80002ce8:	b2 0a       	st.h	r9[0x0],r10

		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
80002cea:	30 09       	mov	r9,0
80002cec:	b0 09       	st.h	r8[0x0],r9
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
80002cee:	fe 69 11 60 	mov	r9,-126624
80002cf2:	30 28       	mov	r8,2
80002cf4:	93 08       	st.w	r9[0x0],r8

	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
80002cf6:	31 08       	mov	r8,16
80002cf8:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002cfa:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002cfe:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_nak_in_interrupt(0);
80002d00:	fe 6a 11 f0 	mov	r10,-126480
80002d04:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002d06:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002d0a:	c1 19       	rjmp	80002f2c <udd_interrupt+0x488>
	if (Is_udd_out_received(0)) {
		// OUT packet received
		udd_ctrl_out_received();
		return true;
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
80002d0c:	fe 68 11 30 	mov	r8,-126672
80002d10:	70 08       	ld.w	r8,r8[0x0]
80002d12:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002d16:	c0 a0       	breq	80002d2a <udd_interrupt+0x286>
80002d18:	fe 68 11 c0 	mov	r8,-126528
80002d1c:	70 08       	ld.w	r8,r8[0x0]
80002d1e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002d22:	c0 40       	breq	80002d2a <udd_interrupt+0x286>
		// IN packet sent
		udd_ctrl_in_sent();
80002d24:	f0 1f 00 96 	mcall	80002f7c <udd_interrupt+0x4d8>
80002d28:	c0 29       	rjmp	80002f2c <udd_interrupt+0x488>
		return true;
	}
	if (Is_udd_nak_out(0)) {
80002d2a:	fe 68 11 30 	mov	r8,-126672
80002d2e:	70 08       	ld.w	r8,r8[0x0]
80002d30:	e2 18 00 08 	andl	r8,0x8,COH
80002d34:	c1 80       	breq	80002d64 <udd_interrupt+0x2c0>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
80002d36:	30 89       	mov	r9,8
80002d38:	fe 68 11 60 	mov	r8,-126624
80002d3c:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0)) {
80002d3e:	fe 68 11 30 	mov	r8,-126672
80002d42:	70 08       	ld.w	r8,r8[0x0]
80002d44:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002d48:	e0 81 00 f2 	brne	80002f2c <udd_interrupt+0x488>
	}

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
80002d4c:	fe f8 02 04 	ld.w	r8,pc[516]
80002d50:	70 08       	ld.w	r8,r8[0x0]
80002d52:	58 38       	cp.w	r8,3
80002d54:	e0 81 00 ec 	brne	80002f2c <udd_interrupt+0x488>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
80002d58:	e8 69 00 00 	mov	r9,524288
80002d5c:	fe 68 11 f0 	mov	r8,-126480
80002d60:	91 09       	st.w	r8[0x0],r9
80002d62:	ce 58       	rjmp	80002f2c <udd_interrupt+0x488>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
80002d64:	fe 68 11 30 	mov	r8,-126672
80002d68:	70 08       	ld.w	r8,r8[0x0]
80002d6a:	e2 18 00 10 	andl	r8,0x10,COH
80002d6e:	c1 c0       	breq	80002da6 <udd_interrupt+0x302>
		// Underflow on IN packet
		udd_ack_nak_in(0);
80002d70:	31 09       	mov	r9,16
80002d72:	fe 68 11 60 	mov	r8,-126624
80002d76:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
80002d78:	fe 68 11 30 	mov	r8,-126672
80002d7c:	70 08       	ld.w	r8,r8[0x0]
80002d7e:	e2 18 00 02 	andl	r8,0x2,COH
80002d82:	e0 81 00 d5 	brne	80002f2c <udd_interrupt+0x488>
		return; // underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
80002d86:	4f 38       	lddpc	r8,80002f50 <udd_interrupt+0x4ac>
80002d88:	70 08       	ld.w	r8,r8[0x0]
80002d8a:	58 18       	cp.w	r8,1
80002d8c:	c0 41       	brne	80002d94 <udd_interrupt+0x2f0>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
80002d8e:	f0 1f 00 7d 	mcall	80002f80 <udd_interrupt+0x4dc>
80002d92:	cc d8       	rjmp	80002f2c <udd_interrupt+0x488>

	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
80002d94:	58 48       	cp.w	r8,4
80002d96:	e0 81 00 cb 	brne	80002f2c <udd_interrupt+0x488>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
80002d9a:	e8 69 00 00 	mov	r9,524288
80002d9e:	fe 68 11 f0 	mov	r8,-126480
80002da2:	91 09       	st.w	r8[0x0],r9
80002da4:	cc 48       	rjmp	80002f2c <udd_interrupt+0x488>
80002da6:	30 08       	mov	r8,0
{
	udd_ep_id_t ep;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		if (!Is_udd_endpoint_interrupt_enabled(ep) || !Is_udd_endpoint_interrupt(ep)) {
80002da8:	fe 6b 10 00 	mov	r11,-126976
80002dac:	e0 67 10 00 	mov	r7,4096
80002db0:	76 4a       	ld.w	r10,r11[0x10]
 */
#ifdef UHD_ENABLE
void udd_interrupt(void); // To avoid GCC warning
void udd_interrupt(void)
#else
ISR(udd_interrupt, AVR32_USBC_IRQ_GROUP, UDD_USB_INT_LEVEL)
80002db2:	2f f8       	sub	r8,-1
80002db4:	10 9c       	mov	r12,r8
{
	udd_ep_id_t ep;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		if (!Is_udd_endpoint_interrupt_enabled(ep) || !Is_udd_endpoint_interrupt(ep)) {
80002db6:	ee 08 09 49 	lsl	r9,r7,r8
80002dba:	f3 ea 00 0a 	and	r10,r9,r10
80002dbe:	c0 40       	breq	80002dc6 <udd_interrupt+0x322>
80002dc0:	76 1a       	ld.w	r10,r11[0x4]
80002dc2:	14 69       	and	r9,r10
80002dc4:	c0 41       	brne	80002dcc <udd_interrupt+0x328>
static bool udd_ep_interrupt(void)
{
	udd_ep_id_t ep;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
80002dc6:	58 38       	cp.w	r8,3
80002dc8:	cf 41       	brne	80002db0 <udd_interrupt+0x30c>
80002dca:	cb 88       	rjmp	80002f3a <udd_interrupt+0x496>
		if (!Is_udd_endpoint_interrupt_enabled(ep) || !Is_udd_endpoint_interrupt(ep)) {
			continue;
		}
		udd_ep_trans_done(ep, false);
80002dcc:	30 0b       	mov	r11,0
80002dce:	f0 1f 00 6e 	mcall	80002f84 <udd_interrupt+0x4e0>
80002dd2:	ca d8       	rjmp	80002f2c <udd_interrupt+0x488>
	}
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
		udd_ack_reset();
80002dd4:	30 87       	mov	r7,8
80002dd6:	fe 68 10 08 	mov	r8,-126968
80002dda:	91 07       	st.w	r8[0x0],r7
#if (USB_DEVICE_MAX_EP != 0)
		// For each endpoint, kill job
		{
			uint8_t i;
			for (i = 1; i <= USB_DEVICE_MAX_EP; i++) {
				udd_ep_abort(i);
80002ddc:	30 1c       	mov	r12,1
80002dde:	f0 1f 00 6b 	mcall	80002f88 <udd_interrupt+0x4e4>
80002de2:	30 2c       	mov	r12,2
80002de4:	f0 1f 00 69 	mcall	80002f88 <udd_interrupt+0x4e4>
80002de8:	30 3c       	mov	r12,3
80002dea:	f0 1f 00 68 	mcall	80002f88 <udd_interrupt+0x4e4>
			}
		}
#endif
		// Reset USB Device Stack Core
		udc_reset();
80002dee:	f0 1f 00 68 	mcall	80002f8c <udd_interrupt+0x4e8>
static void udd_reset_ep_ctrl(void)
{
	irqflags_t flags;

	// Reset USB address to 0
	udd_configure_address(0);
80002df2:	fe 68 10 00 	mov	r8,-126976
80002df6:	70 09       	ld.w	r9,r8[0x0]
80002df8:	e0 19 ff 80 	andl	r9,0xff80
80002dfc:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
80002dfe:	70 09       	ld.w	r9,r8[0x0]
80002e00:	a7 b9       	sbr	r9,0x7
80002e02:	91 09       	st.w	r8[0x0],r9

	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
80002e04:	fe 69 11 00 	mov	r9,-126720
80002e08:	72 0a       	ld.w	r10,r9[0x0]
80002e0a:	34 0b       	mov	r11,64
80002e0c:	f6 07 0c 47 	max	r7,r11,r7
80002e10:	e0 6b 04 00 	mov	r11,1024
80002e14:	ee 0b 0d 4b 	min	r11,r7,r11
80002e18:	a1 7b       	lsl	r11,0x1
80002e1a:	20 1b       	sub	r11,1
80002e1c:	f6 0b 12 00 	clz	r11,r11
80002e20:	f6 0b 11 1c 	rsub	r11,r11,28
80002e24:	a5 6b       	lsl	r11,0x4
80002e26:	e2 1b 19 74 	andl	r11,0x1974,COH
80002e2a:	e0 1a e6 8b 	andl	r10,0xe68b
80002e2e:	f7 ea 10 0a 	or	r10,r11,r10
80002e32:	93 0a       	st.w	r9[0x0],r10
			USB_EP_TYPE_CONTROL,
			0,
			USB_DEVICE_EP_CTRL_SIZE, AVR32_USBC_UECFG0_EPBK_SINGLE);

	// Use internal buffer for endpoint control
	udd_udesc_set_buf0_addr(0, udd_ctrl_buffer);
80002e34:	4c a9       	lddpc	r9,80002f5c <udd_interrupt+0x4b8>
80002e36:	4c da       	lddpc	r10,80002f68 <udd_interrupt+0x4c4>
80002e38:	93 0a       	st.w	r9[0x0],r10

	// don't use multipacket on endpoint control
	udd_udesc_rst_buf0_size(0);
80002e3a:	72 1a       	ld.w	r10,r9[0x4]
80002e3c:	30 0b       	mov	r11,0
80002e3e:	f5 db d2 0f 	bfins	r10,r11,0x10,0xf
80002e42:	93 1a       	st.w	r9[0x4],r10
	udd_enable_endpoint(0);
80002e44:	70 79       	ld.w	r9,r8[0x1c]
80002e46:	a1 a9       	sbr	r9,0x0
80002e48:	91 79       	st.w	r8[0x1c],r9
	udd_disable_busy_bank0(0);
80002e4a:	fc 1a 01 00 	movh	r10,0x100
80002e4e:	fe 69 12 20 	mov	r9,-126432
80002e52:	93 0a       	st.w	r9[0x0],r10

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002e54:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002e58:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_setup_received_interrupt(0);
80002e5a:	fe 69 11 f0 	mov	r9,-126480
80002e5e:	30 4b       	mov	r11,4
80002e60:	93 0b       	st.w	r9[0x0],r11
	udd_enable_out_received_interrupt(0);
80002e62:	30 2b       	mov	r11,2
80002e64:	93 0b       	st.w	r9[0x0],r11
	udd_enable_endpoint_interrupt(0);
80002e66:	e0 69 10 00 	mov	r9,4096
80002e6a:	91 69       	st.w	r8[0x18],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002e6c:	e3 ba 00 00 	mtsr	0x0,r10
		// Reset USB Device Stack Core
		udc_reset();
		// Reset endpoint control
		udd_reset_ep_ctrl();
		// Reset endpoint control management
		udd_ctrl_init();
80002e70:	f0 1f 00 3a 	mcall	80002f58 <udd_interrupt+0x4b4>
		goto udd_interrupt_end;
80002e74:	c5 c8       	rjmp	80002f2c <udd_interrupt+0x488>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
80002e76:	fe 68 10 10 	mov	r8,-126960
80002e7a:	70 08       	ld.w	r8,r8[0x0]
80002e7c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002e80:	c1 b0       	breq	80002eb6 <udd_interrupt+0x412>
80002e82:	fe 68 10 04 	mov	r8,-126972
80002e86:	70 08       	ld.w	r8,r8[0x0]
80002e88:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002e8c:	c1 50       	breq	80002eb6 <udd_interrupt+0x412>
		otg_unfreeze_clock();
80002e8e:	fe 68 18 00 	mov	r8,-124928
80002e92:	70 09       	ld.w	r9,r8[0x0]
80002e94:	af c9       	cbr	r9,0xe
80002e96:	91 09       	st.w	r8[0x0],r9
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
80002e98:	30 1a       	mov	r10,1
80002e9a:	fe 69 10 14 	mov	r9,-126956
80002e9e:	93 0a       	st.w	r9[0x0],r10
		udd_enable_wake_up_interrupt();
80002ea0:	31 0a       	mov	r10,16
80002ea2:	fe 69 10 18 	mov	r9,-126952
80002ea6:	93 0a       	st.w	r9[0x0],r10
		otg_freeze_clock(); // Mandatory to exit of sleep mode after a wakeup event
80002ea8:	70 09       	ld.w	r9,r8[0x0]
80002eaa:	af a9       	sbr	r9,0xe
80002eac:	91 09       	st.w	r8[0x0],r9
		udd_sleep_mode(false); // Enter in SUSPEND mode
80002eae:	30 0c       	mov	r12,0
80002eb0:	f0 1f 00 38 	mcall	80002f90 <udd_interrupt+0x4ec>
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_end;
80002eb4:	c3 c8       	rjmp	80002f2c <udd_interrupt+0x488>
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
80002eb6:	fe 68 10 10 	mov	r8,-126960
80002eba:	70 08       	ld.w	r8,r8[0x0]
80002ebc:	e2 18 00 10 	andl	r8,0x10,COH
80002ec0:	c1 d0       	breq	80002efa <udd_interrupt+0x456>
80002ec2:	fe 68 10 04 	mov	r8,-126972
80002ec6:	70 08       	ld.w	r8,r8[0x0]
80002ec8:	e2 18 00 10 	andl	r8,0x10,COH
80002ecc:	c1 70       	breq	80002efa <udd_interrupt+0x456>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
80002ece:	fe 68 18 00 	mov	r8,-124928
80002ed2:	70 09       	ld.w	r9,r8[0x0]
80002ed4:	af c9       	cbr	r9,0xe
80002ed6:	91 09       	st.w	r8[0x0],r9

		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_otg_clock_usable() );
80002ed8:	fe 69 18 04 	mov	r9,-124924
80002edc:	72 08       	ld.w	r8,r9[0x0]
80002ede:	e2 18 40 00 	andl	r8,0x4000,COH
80002ee2:	cf d0       	breq	80002edc <udd_interrupt+0x438>

		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
80002ee4:	31 09       	mov	r9,16
80002ee6:	fe 68 10 14 	mov	r8,-126956
80002eea:	91 09       	st.w	r8[0x0],r9
		udd_enable_suspend_interrupt();
80002eec:	30 1c       	mov	r12,1
80002eee:	fe 68 10 18 	mov	r8,-126952
80002ef2:	91 0c       	st.w	r8[0x0],r12
		udd_sleep_mode(true); // Enter in IDLE mode
80002ef4:	f0 1f 00 27 	mcall	80002f90 <udd_interrupt+0x4ec>
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		goto udd_interrupt_end;
80002ef8:	c1 a8       	rjmp	80002f2c <udd_interrupt+0x488>
	}

	if (Is_otg_vbus_transition()) {
80002efa:	fe 68 18 04 	mov	r8,-124924
80002efe:	70 08       	ld.w	r8,r8[0x0]
80002f00:	e2 18 00 02 	andl	r8,0x2,COH
80002f04:	c1 40       	breq	80002f2c <udd_interrupt+0x488>
		// Ack Vbus transition and send status to high level
		otg_unfreeze_clock();
80002f06:	fe 68 18 00 	mov	r8,-124928
80002f0a:	70 09       	ld.w	r9,r8[0x0]
80002f0c:	af c9       	cbr	r9,0xe
80002f0e:	91 09       	st.w	r8[0x0],r9
		otg_ack_vbus_transition();
80002f10:	30 2a       	mov	r10,2
80002f12:	fe 69 18 08 	mov	r9,-124920
80002f16:	93 0a       	st.w	r9[0x0],r10
		otg_freeze_clock();
80002f18:	70 09       	ld.w	r9,r8[0x0]
80002f1a:	af a9       	sbr	r9,0xe
80002f1c:	91 09       	st.w	r8[0x0],r9
#ifdef UDC_VBUS_EVENT
		UDC_VBUS_EVENT(Is_otg_vbus_high());
80002f1e:	fe 68 18 04 	mov	r8,-124924
80002f22:	70 0c       	ld.w	r12,r8[0x0]
80002f24:	f9 dc c1 61 	bfextu	r12,r12,0xb,0x1
80002f28:	f0 1f 00 1b 	mcall	80002f94 <udd_interrupt+0x4f0>
#endif
		goto udd_interrupt_end;
	}
udd_interrupt_end:
	otg_data_memory_barrier();
80002f2c:	fe 68 10 00 	mov	r8,-126976
80002f30:	f0 f8 08 18 	ld.w	r8,r8[2072]
	return;
}
80002f34:	e3 cd 40 80 	ldm	sp++,r7,lr
80002f38:	d6 03       	rete
		goto udd_interrupt_end;
	}
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
80002f3a:	fe 68 10 04 	mov	r8,-126972
80002f3e:	70 08       	ld.w	r8,r8[0x0]
80002f40:	e2 18 00 08 	andl	r8,0x8,COH
80002f44:	fe 91 ff 48 	brne	80002dd4 <udd_interrupt+0x330>
80002f48:	c9 7b       	rjmp	80002e76 <udd_interrupt+0x3d2>
80002f4a:	00 00       	add	r0,r0
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	38 28       	mov	r8,-126
80002f50:	00 00       	add	r0,r0
80002f52:	03 64       	ld.uh	r4,--r1
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	24 74       	sub	r4,71
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	24 34       	sub	r4,67
80002f5c:	00 00       	add	r0,r0
80002f5e:	02 e0       	st.h	--r1,r0
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	24 5c       	sub	r12,69
80002f64:	00 00       	add	r0,r0
80002f66:	05 7c       	ld.ub	r12,--r2
80002f68:	00 00       	add	r0,r0
80002f6a:	05 94       	ld.ub	r4,r2[0x1]
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	42 7a       	lddsp	r10,sp[0x9c]
80002f70:	80 00       	ld.sh	r0,r0[0x0]
80002f72:	3a a8       	mov	r8,-86
80002f74:	00 00       	add	r0,r0
80002f76:	02 88       	andn	r8,r1
80002f78:	00 00       	add	r0,r0
80002f7a:	03 62       	ld.uh	r2,--r1
80002f7c:	80 00       	ld.sh	r0,r0[0x0]
80002f7e:	26 34       	sub	r4,99
80002f80:	80 00       	ld.sh	r0,r0[0x0]
80002f82:	25 f8       	sub	r8,95
80002f84:	80 00       	ld.sh	r0,r0[0x0]
80002f86:	27 44       	sub	r4,116
80002f88:	80 00       	ld.sh	r0,r0[0x0]
80002f8a:	2a 30       	sub	r0,-93
80002f8c:	80 00       	ld.sh	r0,r0[0x0]
80002f8e:	3a 48       	mov	r8,-92
80002f90:	80 00       	ld.sh	r0,r0[0x0]
80002f92:	25 14       	sub	r4,81
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	3f 3c       	mov	r12,-13

80002f98 <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
80002f98:	eb cd 40 f8 	pushm	r3-r7,lr
	udd_ep_id_t ep_num;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	ep_num = ep & USB_EP_ADDR_MASK;
80002f9c:	fd dc c0 04 	bfextu	lr,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep_num) {
80002fa0:	30 37       	mov	r7,3
80002fa2:	ee 0e 18 00 	cp.b	lr,r7
80002fa6:	e0 8b 00 66 	brhi	80003072 <udd_ep_run+0xda>
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep_num - 1];

	if ((!Is_udd_endpoint_enabled(ep_num))
80002faa:	fe 67 10 00 	mov	r7,-126976
80002fae:	6e 76       	ld.w	r6,r7[0x1c]
80002fb0:	1c 95       	mov	r5,lr
80002fb2:	30 17       	mov	r7,1
80002fb4:	ee 0e 09 47 	lsl	r7,r7,lr
80002fb8:	0c 67       	and	r7,r6
80002fba:	c5 c0       	breq	80003072 <udd_ep_run+0xda>
			|| Is_udd_endpoint_stall_requested(ep_num)) {
80002fbc:	fc 07 15 02 	lsl	r7,lr,0x2
80002fc0:	fe 64 11 c0 	mov	r4,-126528
80002fc4:	ee 04 00 06 	add	r6,r7,r4
80002fc8:	6c 06       	ld.w	r6,r6[0x0]
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep_num - 1];

	if ((!Is_udd_endpoint_enabled(ep_num))
80002fca:	e6 16 00 08 	andh	r6,0x8,COH
80002fce:	c5 21       	brne	80003072 <udd_ep_run+0xda>
	if (USB_DEVICE_MAX_EP < ep_num) {
		return false;
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep_num - 1];
80002fd0:	20 1e       	sub	lr,1
80002fd2:	fc 0e 00 2e 	add	lr,lr,lr<<0x2
80002fd6:	4a 96       	lddpc	r6,80003078 <udd_ep_run+0xe0>
80002fd8:	ec 0e 00 2e 	add	lr,r6,lr<<0x2

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002fdc:	e1 b4 00 00 	mfsr	r4,0x0
	cpu_irq_disable();
80002fe0:	d3 03       	ssrf	0x10
			|| Is_udd_endpoint_stall_requested(ep_num)) {
		return false; // Endpoint is halted
	}

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
80002fe2:	7c 06       	ld.w	r6,lr[0x0]
80002fe4:	58 06       	cp.w	r6,0
80002fe6:	c0 54       	brge	80002ff0 <udd_ep_run+0x58>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002fe8:	e3 b4 00 00 	mtsr	0x0,r4
#endif
	barrier();
80002fec:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		cpu_irq_restore(flags);
		return false; // Job already on going
	}
	ptr_job->busy = true;
80002ff0:	7c 06       	ld.w	r6,lr[0x0]
80002ff2:	30 13       	mov	r3,1
80002ff4:	ed d3 d3 e1 	bfins	r6,r3,0x1f,0x1
80002ff8:	9d 06       	st.w	lr[0x0],r6
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002ffa:	e3 b4 00 00 	mtsr	0x0,r4
	cpu_irq_restore(flags);

	// No job running. Let's setup a new one.
	//
	ptr_job->buf = buf;
80002ffe:	9d 1a       	st.w	lr[0x4],r10
	ptr_job->buf_size = buf_size;
80003000:	9d 29       	st.w	lr[0x8],r9
	ptr_job->nb_trans = 0;
80003002:	30 0a       	mov	r10,0
80003004:	9d 3a       	st.w	lr[0xc],r10
	ptr_job->call_trans = callback;
80003006:	9d 48       	st.w	lr[0x10],r8
	ptr_job->b_shortpacket = b_shortpacket;
80003008:	7c 08       	ld.w	r8,lr[0x0]
8000300a:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
	ptr_job->b_use_out_cache_buffer = false;
8000300e:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
80003012:	9d 08       	st.w	lr[0x0],r8

	if ( (USB_EP_DIR_IN != (ep & USB_EP_DIR_IN))
80003014:	f4 0c 18 00 	cp.b	r12,r10
80003018:	c1 95       	brlt	8000304a <udd_ep_run+0xb2>
			&& (AVR32_USBC_PTYPE_ISOCHRONOUS == udd_get_endpoint_type(ep_num))
8000301a:	e0 37 ef 00 	sub	r7,126720
8000301e:	6e 08       	ld.w	r8,r7[0x0]
	ptr_job->nb_trans = 0;
	ptr_job->call_trans = callback;
	ptr_job->b_shortpacket = b_shortpacket;
	ptr_job->b_use_out_cache_buffer = false;

	if ( (USB_EP_DIR_IN != (ep & USB_EP_DIR_IN))
80003020:	f1 d8 c1 62 	bfextu	r8,r8,0xb,0x2
80003024:	06 38       	cp.w	r8,r3
80003026:	c1 21       	brne	8000304a <udd_ep_run+0xb2>
			&& (AVR32_USBC_PTYPE_ISOCHRONOUS == udd_get_endpoint_type(ep_num))
			&& (0 != (buf_size % udd_get_endpoint_size(ep_num)))) {
80003028:	6e 08       	ld.w	r8,r7[0x0]
	ptr_job->nb_trans = 0;
	ptr_job->call_trans = callback;
	ptr_job->b_shortpacket = b_shortpacket;
	ptr_job->b_use_out_cache_buffer = false;

	if ( (USB_EP_DIR_IN != (ep & USB_EP_DIR_IN))
8000302a:	f1 d8 c0 83 	bfextu	r8,r8,0x4,0x3
8000302e:	30 8a       	mov	r10,8
80003030:	f4 08 09 48 	lsl	r8,r10,r8
80003034:	20 18       	sub	r8,1
80003036:	f1 e9 00 09 	and	r9,r8,r9
8000303a:	c0 80       	breq	8000304a <udd_ep_run+0xb2>
			&& (AVR32_USBC_PTYPE_ISOCHRONOUS == udd_get_endpoint_type(ep_num))
			&& (0 != (buf_size % udd_get_endpoint_size(ep_num)))) {
		// The user must use a buffer size modulo endpoint size
		// for an isochronous IN endpoint
		ptr_job->busy = false;
8000303c:	7c 08       	ld.w	r8,lr[0x0]
8000303e:	30 0c       	mov	r12,0
80003040:	f1 dc d3 e1 	bfins	r8,r12,0x1f,0x1
80003044:	9d 08       	st.w	lr[0x0],r8
		return false;
80003046:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
	}

	// Initialize value to simulate a empty transfer
	udd_udesc_rst_buf0_ctn(ep_num);
8000304a:	48 d8       	lddpc	r8,8000307c <udd_ep_run+0xe4>
8000304c:	a3 75       	lsl	r5,0x3
8000304e:	2f f5       	sub	r5,-1
80003050:	f0 05 03 29 	ld.w	r9,r8[r5<<0x2]
80003054:	30 0b       	mov	r11,0
80003056:	f3 db d0 0f 	bfins	r9,r11,0x0,0xf
8000305a:	f0 05 09 29 	st.w	r8[r5<<0x2],r9
	udd_udesc_rst_buf0_size(ep_num);
8000305e:	f0 05 03 29 	ld.w	r9,r8[r5<<0x2]
80003062:	f3 db d2 0f 	bfins	r9,r11,0x10,0xf
80003066:	f0 05 09 29 	st.w	r8[r5<<0x2],r9

	// Request next transfer
	udd_ep_trans_done(ep, false);
8000306a:	f0 1f 00 06 	mcall	80003080 <udd_ep_run+0xe8>
8000306e:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
	return true;
80003072:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80003076:	00 00       	add	r0,r0
80003078:	00 00       	add	r0,r0
8000307a:	02 8c       	andn	r12,r1
8000307c:	00 00       	add	r0,r0
8000307e:	02 e0       	st.h	--r1,r0
80003080:	80 00       	ld.sh	r0,r0[0x0]
80003082:	27 44       	sub	r4,116

80003084 <udd_enable>:
#endif
}


void udd_enable(void)
{
80003084:	eb cd 40 c0 	pushm	r6-r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003088:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
8000308c:	d3 03       	ssrf	0x10
		cpu_irq_restore(flags);
		return;
	}
#else
	//* SINGLE DEVICE MODE INITIALIZATION
	sysclk_enable_usb();
8000308e:	f0 1f 00 35 	mcall	80003160 <udd_enable+0xdc>

	// Here, only the device mode is possible, then link USBC interrupt to UDD interrupt
	irq_register_handler(udd_interrupt, AVR32_USBC_IRQ, UDD_USB_INT_LEVEL);
80003092:	30 0a       	mov	r10,0
80003094:	e0 6b 01 00 	mov	r11,256
80003098:	4b 3c       	lddpc	r12,80003164 <udd_enable+0xe0>
8000309a:	f0 1f 00 34 	mcall	80003168 <udd_enable+0xe4>
#if defined (__GNUC__)
__attribute__((__always_inline__))
#endif
static inline void pm_asyn_wake_up_enable(unsigned long awen_mask)
{
  AVR32_PM.awen |= awen_mask;
8000309e:	fe 78 04 00 	mov	r8,-64512
800030a2:	f0 f9 01 88 	ld.w	r9,r8[392]
800030a6:	a1 a9       	sbr	r9,0x0
800030a8:	f1 49 01 88 	st.w	r8[392],r9
		cpu_irq_restore(flags);
		return; // Device is not the current mode
	}
# else
	// ID pin not used then force device mode
	otg_disable_id_pin();
800030ac:	fe 68 18 00 	mov	r8,-124928
800030b0:	70 09       	ld.w	r9,r8[0x0]
800030b2:	b9 c9       	cbr	r9,0x18
800030b4:	91 09       	st.w	r8[0x0],r9
	otg_force_device_mode();
800030b6:	70 09       	ld.w	r9,r8[0x0]
800030b8:	b9 b9       	sbr	r9,0x19
800030ba:	91 09       	st.w	r8[0x0],r9
# endif

	// Enable USB hardware
	otg_enable_pad();
800030bc:	70 09       	ld.w	r9,r8[0x0]
800030be:	ad a9       	sbr	r9,0xc
800030c0:	91 09       	st.w	r8[0x0],r9
	otg_enable();
800030c2:	70 09       	ld.w	r9,r8[0x0]
800030c4:	af b9       	sbr	r9,0xf
800030c6:	91 09       	st.w	r8[0x0],r9
	otg_unfreeze_clock();
800030c8:	70 09       	ld.w	r9,r8[0x0]
800030ca:	af c9       	cbr	r9,0xe
800030cc:	91 09       	st.w	r8[0x0],r9
	(void)Is_otg_clock_frozen();
800030ce:	70 08       	ld.w	r8,r8[0x0]

	memset((uint8_t *) udd_g_ep_table, 0, sizeof(udd_g_ep_table));
800030d0:	4a 77       	lddpc	r7,8000316c <udd_enable+0xe8>
800030d2:	e0 6a 00 80 	mov	r10,128
800030d6:	30 0b       	mov	r11,0
800030d8:	0e 9c       	mov	r12,r7
800030da:	f0 1f 00 26 	mcall	80003170 <udd_enable+0xec>
	otg_register_desc_tab(udd_g_ep_table);
800030de:	fe 68 10 00 	mov	r8,-126976
800030e2:	f0 f9 08 30 	ld.w	r9,r8[2096]
800030e6:	f1 47 08 30 	st.w	r8[2096],r7
	// Reset internal variables
#if (0!=USB_DEVICE_MAX_EP)
	{
		uint8_t i;
		for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
			udd_ep_job[i].busy = false;
800030ea:	4a 39       	lddpc	r9,80003174 <udd_enable+0xf0>
800030ec:	72 0b       	ld.w	r11,r9[0x0]
800030ee:	30 0a       	mov	r10,0
800030f0:	f7 da d3 e1 	bfins	r11,r10,0x1f,0x1
800030f4:	93 0b       	st.w	r9[0x0],r11
800030f6:	72 5b       	ld.w	r11,r9[0x14]
800030f8:	f7 da d3 e1 	bfins	r11,r10,0x1f,0x1
800030fc:	93 5b       	st.w	r9[0x14],r11
800030fe:	72 ab       	ld.w	r11,r9[0x28]
80003100:	f7 da d3 e1 	bfins	r11,r10,0x1f,0x1
80003104:	93 ab       	st.w	r9[0x28],r11

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
80003106:	70 09       	ld.w	r9,r8[0x0]
80003108:	ad c9       	cbr	r9,0xc
8000310a:	91 09       	st.w	r8[0x0],r9
#  ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
#  else
	udd_high_speed_disable();
8000310c:	70 09       	ld.w	r9,r8[0x0]
8000310e:	e8 19 0c 00 	orl	r9,0xc00
80003112:	91 09       	st.w	r8[0x0],r9
#  endif
#endif
	otg_ack_vbus_transition();
80003114:	30 29       	mov	r9,2
80003116:	fe 68 18 08 	mov	r8,-124920
8000311a:	91 09       	st.w	r8[0x0],r9
	// Force Vbus interrupt in case of Vbus always with a high level
	// This is possible with a short timing between a Host mode stop/start.
	if (Is_otg_vbus_high()) {
8000311c:	fe 68 18 04 	mov	r8,-124924
80003120:	70 08       	ld.w	r8,r8[0x0]
80003122:	e2 18 08 00 	andl	r8,0x800,COH
80003126:	c0 40       	breq	8000312e <udd_enable+0xaa>
		otg_raise_vbus_transition();
80003128:	fe 68 18 0c 	mov	r8,-124916
8000312c:	91 09       	st.w	r8[0x0],r9
	}
	otg_enable_vbus_interrupt();
8000312e:	fe 68 18 00 	mov	r8,-124928
80003132:	70 09       	ld.w	r9,r8[0x0]
80003134:	a1 b9       	sbr	r9,0x1
80003136:	91 09       	st.w	r8[0x0],r9
	otg_freeze_clock();
80003138:	70 09       	ld.w	r9,r8[0x0]
8000313a:	af a9       	sbr	r9,0xe
8000313c:	91 09       	st.w	r8[0x0],r9

#ifndef UDD_NO_SLEEP_MGR
	// Initialize the sleep mode authorized for the USB suspend mode
	udd_b_idle = false;
8000313e:	30 09       	mov	r9,0
80003140:	48 e8       	lddpc	r8,80003178 <udd_enable+0xf4>
80003142:	b0 89       	st.b	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003144:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80003148:	d3 03       	ssrf	0x10
8000314a:	48 d8       	lddpc	r8,8000317c <udd_enable+0xf8>
8000314c:	11 ca       	ld.ub	r10,r8[0x4]
8000314e:	2f fa       	sub	r10,-1
80003150:	b0 ca       	st.b	r8[0x4],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003152:	e3 b9 00 00 	mtsr	0x0,r9
80003156:	e3 b6 00 00 	mtsr	0x0,r6
	sleepmgr_lock_mode(USBC_SLEEP_MODE_USB_SUSPEND);
#endif

	cpu_irq_restore(flags);
}
8000315a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000315e:	00 00       	add	r0,r0
80003160:	80 00       	ld.sh	r0,r0[0x0]
80003162:	32 74       	mov	r4,39
80003164:	80 00       	ld.sh	r0,r0[0x0]
80003166:	2a a4       	sub	r4,-86
80003168:	80 00       	ld.sh	r0,r0[0x0]
8000316a:	22 70       	sub	r0,39
8000316c:	00 00       	add	r0,r0
8000316e:	02 e0       	st.h	--r1,r0
80003170:	80 00       	ld.sh	r0,r0[0x0]
80003172:	43 c2       	lddsp	r2,sp[0xf0]
80003174:	00 00       	add	r0,r0
80003176:	02 8c       	andn	r12,r1
80003178:	00 00       	add	r0,r0
8000317a:	03 60       	ld.uh	r0,--r1
8000317c:	00 00       	add	r0,r0
8000317e:	05 d4       	ld.ub	r4,r2[0x5]

80003180 <delay_init>:
//_____ D E C L A R A T I O N S ____________________________________________

void delay_init(unsigned long fcpu_hz)
{
#ifndef FREERTOS_USED
  s_fcpu_hz = fcpu_hz;
80003180:	48 28       	lddpc	r8,80003188 <delay_init+0x8>
80003182:	91 0c       	st.w	r8[0x0],r12
#endif
}
80003184:	5e fc       	retal	r12
80003186:	00 00       	add	r0,r0
80003188:	00 00       	add	r0,r0
8000318a:	03 68       	ld.uh	r8,--r1

8000318c <delay_ms>:


void delay_ms(unsigned long delay)
{
8000318c:	eb cd 40 c0 	pushm	r6-r7,lr
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static inline uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80003190:	49 38       	lddpc	r8,800031dc <delay_ms+0x50>
80003192:	70 07       	ld.w	r7,r8[0x0]
80003194:	f8 07 06 46 	mulu.d	r6,r12,r7
80003198:	e0 68 03 e8 	mov	r8,1000
8000319c:	30 09       	mov	r9,0
8000319e:	e0 6a 03 e7 	mov	r10,999
800031a2:	30 0b       	mov	r11,0
800031a4:	ec 0a 00 0a 	add	r10,r6,r10
800031a8:	ee 0b 00 4b 	adc	r11,r7,r11
800031ac:	f0 1f 00 0d 	mcall	800031e0 <delay_ms+0x54>
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static inline void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800031b0:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800031b4:	f0 0a 00 0a 	add	r10,r8,r10
#if (defined __GNUC__)
__attribute__((__always_inline__))
#endif
static inline unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800031b8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occured.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800031bc:	14 38       	cp.w	r8,r10
800031be:	e0 88 00 08 	brls	800031ce <delay_ms+0x42>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800031c2:	12 38       	cp.w	r8,r9
800031c4:	fe 98 ff fa 	brls	800031b8 <delay_ms+0x2c>
800031c8:	12 3a       	cp.w	r10,r9
800031ca:	c0 73       	brcs	800031d8 <delay_ms+0x4c>
800031cc:	cf 6b       	rjmp	800031b8 <delay_ms+0x2c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800031ce:	12 38       	cp.w	r8,r9
800031d0:	e0 8b 00 04 	brhi	800031d8 <delay_ms+0x4c>
800031d4:	12 3a       	cp.w	r10,r9
800031d6:	cf 12       	brcc	800031b8 <delay_ms+0x2c>
800031d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800031dc:	00 00       	add	r0,r0
800031de:	03 68       	ld.uh	r8,--r1
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	3f e8       	mov	r8,-2

800031e4 <_stext>:
800031e4:	48 dd       	lddpc	sp,80003218 <udata_clear_loop_end+0x4>
800031e6:	fe c0 ed e6 	sub	r0,pc,-4634
800031ea:	e3 b0 00 01 	mtsr	0x4,r0
800031ee:	d5 53       	csrf	0x15
800031f0:	48 b0       	lddpc	r0,8000321c <udata_clear_loop_end+0x8>
800031f2:	48 c1       	lddpc	r1,80003220 <udata_clear_loop_end+0xc>
800031f4:	02 30       	cp.w	r0,r1
800031f6:	c0 62       	brcc	80003202 <idata_load_loop_end>
800031f8:	48 b2       	lddpc	r2,80003224 <udata_clear_loop_end+0x10>

800031fa <idata_load_loop>:
800031fa:	a5 05       	ld.d	r4,r2++
800031fc:	a1 24       	st.d	r0++,r4
800031fe:	02 30       	cp.w	r0,r1
80003200:	cf d3       	brcs	800031fa <idata_load_loop>

80003202 <idata_load_loop_end>:
80003202:	48 a0       	lddpc	r0,80003228 <udata_clear_loop_end+0x14>
80003204:	48 a1       	lddpc	r1,8000322c <udata_clear_loop_end+0x18>
80003206:	02 30       	cp.w	r0,r1
80003208:	c0 62       	brcc	80003214 <udata_clear_loop_end>
8000320a:	30 02       	mov	r2,0
8000320c:	30 03       	mov	r3,0

8000320e <udata_clear_loop>:
8000320e:	a1 22       	st.d	r0++,r2
80003210:	02 30       	cp.w	r0,r1
80003212:	cf e3       	brcs	8000320e <udata_clear_loop>

80003214 <udata_clear_loop_end>:
80003214:	fe cf f2 bc 	sub	pc,pc,-3396
80003218:	00 01       	add	r1,r0
8000321a:	00 00       	add	r0,r0
8000321c:	00 00       	add	r0,r0
8000321e:	00 08       	add	r8,r0
80003220:	00 00       	add	r0,r0
80003222:	00 a8       	st.w	r0++,r8
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	47 b0       	lddsp	r0,sp[0x1ec]
80003228:	00 00       	add	r0,r0
8000322a:	00 a8       	st.w	r0++,r8
8000322c:	00 00       	add	r0,r0
8000322e:	05 e0       	ld.ub	r0,r2[0x6]

80003230 <osc_priv_enable_osc0>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003230:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80003234:	d3 03       	ssrf	0x10
void osc_priv_enable_osc0(void)
{
	irqflags_t flags;

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_OSCCTRL;
80003236:	fe 78 08 00 	mov	r8,-63488
8000323a:	32 4a       	mov	r10,36
8000323c:	ea 1a aa 00 	orh	r10,0xaa00
80003240:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.oscctrl[0] =
80003242:	e0 7a 0c 07 	mov	r10,68615
80003246:	91 9a       	st.w	r8[0x24],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003248:	e3 b9 00 00 	mtsr	0x0,r9
			(OSC0_STARTUP_VALUE << AVR32_SCIF_OSCCTRL_STARTUP)
			| (OSC0_GAIN_VALUE << AVR32_SCIF_OSCCTRL_GAIN)
			| (OSC0_MODE_VALUE << AVR32_SCIF_OSCCTRL_MODE)
			| (1U << AVR32_SCIF_OSCCTRL_OSCEN);
	cpu_irq_restore(flags);
}
8000324c:	5e fc       	retal	r12

8000324e <pll_enable>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000324e:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80003252:	d3 03       	ssrf	0x10
	irqflags_t flags;

	Assert(pll_id < NR_PLLS);

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | (AVR32_SCIF_PLL + (4 * pll_id));
80003254:	2f 9b       	sub	r11,-7
80003256:	f6 0a 15 02 	lsl	r10,r11,0x2
8000325a:	ea 1a aa 00 	orh	r10,0xaa00
8000325e:	fe 78 08 00 	mov	r8,-63488
80003262:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.pll[pll_id] = cfg->ctrl | (1U << AVR32_SCIF_PLLEN);
80003264:	78 0a       	ld.w	r10,r12[0x0]
80003266:	a1 aa       	sbr	r10,0x0
80003268:	f0 0b 09 2a 	st.w	r8[r11<<0x2],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000326c:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
}
80003270:	5e fc       	retal	r12

80003272 <sysclk_init>:

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = true;
#endif
}
80003272:	5e fc       	retal	r12

80003274 <sysclk_enable_usb>:
 * \pre The USB generick clock must be configurated to 48MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
80003274:	d4 01       	pushm	lr
80003276:	20 1d       	sub	sp,4

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_SCIF.pclksr & (1U << (AVR32_SCIF_PLL0_LOCK + pll_id)));
80003278:	fe 78 08 00 	mov	r8,-63488
8000327c:	70 58       	ld.w	r8,r8[0x14]

static inline void pll_enable_config_defaults(unsigned int pll_id)
{
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
8000327e:	e2 18 00 10 	andl	r8,0x10,COH
80003282:	c2 81       	brne	800032d2 <sysclk_enable_usb+0x5e>
static inline bool osc_is_ready(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_SCIF.pclksr & (1 << AVR32_SCIF_OSC0RDY));
80003284:	fe 78 08 00 	mov	r8,-63488
80003288:	70 58       	ld.w	r8,r8[0x14]

static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
8000328a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000328e:	c0 91       	brne	800032a0 <sysclk_enable_usb+0x2c>
static inline void osc_enable(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		osc_priv_enable_osc0();
80003290:	f0 1f 00 15 	mcall	800032e4 <sysclk_enable_usb+0x70>
static inline bool osc_is_ready(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_SCIF.pclksr & (1 << AVR32_SCIF_OSC0RDY));
80003294:	fe 79 08 00 	mov	r9,-63488
80003298:	72 58       	ld.w	r8,r9[0x14]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
8000329a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000329e:	cf d0       	breq	80003298 <sysclk_enable_usb+0x24>
static inline void pll_config_set_option(struct pll_config *cfg,
		unsigned int option)
{
	Assert(option < PLL_NR_OPTIONS);

	cfg->ctrl |= 1U << (AVR32_SCIF_PLLOPT + option);
800032a0:	31 08       	mov	r8,16
800032a2:	a3 b8       	sbr	r8,0x3
800032a4:	50 08       	stdsp	sp[0x0],r8
		pll_config_set_option(cfg, PLL_OPT_VCO_RANGE_LOW);

	Assert(mul > 2 && mul <= 16);
	Assert(div > 0 && div <= 15);

	cfg->ctrl |= ((mul - 1) << AVR32_SCIF_PLLMUL)
800032a6:	10 99       	mov	r9,r8
800032a8:	ea 19 3f 00 	orh	r9,0x3f00
800032ac:	e8 19 01 00 	orl	r9,0x100
800032b0:	30 68       	mov	r8,6
800032b2:	20 18       	sub	r8,1
800032b4:	f3 e8 11 08 	or	r8,r9,r8<<0x10
800032b8:	fa cc ff fc 	sub	r12,sp,-4
800032bc:	18 d8       	st.w	--r12,r8
#endif
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
800032be:	30 0b       	mov	r11,0
800032c0:	1a 9c       	mov	r12,sp
800032c2:	f0 1f 00 0a 	mcall	800032e8 <sysclk_enable_usb+0x74>

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_SCIF.pclksr & (1U << (AVR32_SCIF_PLL0_LOCK + pll_id)));
800032c6:	fe 79 08 00 	mov	r9,-63488
800032ca:	72 58       	ld.w	r8,r9[0x14]
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
800032cc:	e2 18 00 10 	andl	r8,0x10,COH
800032d0:	cf d0       	breq	800032ca <sysclk_enable_usb+0x56>
}

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
	AVR32_SCIF.gcctrl[id] = cfg->ctrl | (1U << AVR32_SCIF_GCCTRL_CEN);
800032d2:	e0 69 05 01 	mov	r9,1281
800032d6:	fe 78 08 00 	mov	r8,-63488
800032da:	f1 49 00 64 	st.w	r8[100],r9
	genclk_enable_config(AVR32_USBC_GCLK_NUM, CONFIG_USBCLK_SOURCE, CONFIG_USBCLK_DIV);
}
800032de:	2f fd       	sub	sp,-4
800032e0:	d8 02       	popm	pc
800032e2:	00 00       	add	r0,r0
800032e4:	80 00       	ld.sh	r0,r0[0x0]
800032e6:	32 30       	mov	r0,35
800032e8:	80 00       	ld.sh	r0,r0[0x0]
800032ea:	32 4e       	mov	lr,36

800032ec <udi_cdc_data_disable>:
}
#endif

void udi_cdc_data_disable(void)
{
}
800032ec:	5e fc       	retal	r12
800032ee:	d7 03       	nop

800032f0 <udi_cdc_comm_setup>:



static bool udi_cdc_comm_setup_common(uint8_t port)
{
	if (Udd_setup_is_in()) {
800032f0:	49 e8       	lddpc	r8,80003368 <udi_cdc_comm_setup+0x78>
800032f2:	11 88       	ld.ub	r8,r8[0x0]
800032f4:	30 09       	mov	r9,0
800032f6:	f2 08 18 00 	cp.b	r8,r9
800032fa:	c1 84       	brge	8000332a <udi_cdc_comm_setup+0x3a>
		// GET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
800032fc:	e2 18 00 60 	andl	r8,0x60,COH
80003300:	e0 48 00 20 	cp.w	r8,32
80003304:	c3 11       	brne	80003366 <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
80003306:	49 98       	lddpc	r8,80003368 <udi_cdc_comm_setup+0x78>
80003308:	11 99       	ld.ub	r9,r8[0x1]
8000330a:	32 18       	mov	r8,33
8000330c:	f0 09 18 00 	cp.b	r9,r8
80003310:	c2 b1       	brne	80003366 <udi_cdc_comm_setup+0x76>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
80003312:	49 68       	lddpc	r8,80003368 <udi_cdc_comm_setup+0x78>
80003314:	90 39       	ld.sh	r9,r8[0x6]
80003316:	30 78       	mov	r8,7
80003318:	f0 09 19 00 	cp.h	r9,r8
8000331c:	c2 51       	brne	80003366 <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.payload =
8000331e:	49 38       	lddpc	r8,80003368 <udi_cdc_comm_setup+0x78>
80003320:	49 39       	lddpc	r9,8000336c <udi_cdc_comm_setup+0x7c>
80003322:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding[PORT];
				udd_g_ctrlreq.payload_size =
80003324:	30 79       	mov	r9,7
80003326:	b0 69       	st.h	r8[0xc],r9
80003328:	5e ff       	retal	1
			}
		}
	}
	if (Udd_setup_is_out()) {
		// SET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
8000332a:	e2 18 00 60 	andl	r8,0x60,COH
8000332e:	e0 48 00 20 	cp.w	r8,32
80003332:	c1 a1       	brne	80003366 <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
80003334:	48 d8       	lddpc	r8,80003368 <udi_cdc_comm_setup+0x78>
80003336:	11 98       	ld.ub	r8,r8[0x1]
80003338:	32 09       	mov	r9,32
8000333a:	f2 08 18 00 	cp.b	r8,r9
8000333e:	c0 60       	breq	8000334a <udi_cdc_comm_setup+0x5a>
80003340:	32 29       	mov	r9,34
80003342:	f2 08 18 00 	cp.b	r8,r9
80003346:	c1 01       	brne	80003366 <udi_cdc_comm_setup+0x76>
80003348:	5e ff       	retal	1
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
8000334a:	48 88       	lddpc	r8,80003368 <udi_cdc_comm_setup+0x78>
8000334c:	90 39       	ld.sh	r9,r8[0x6]
8000334e:	30 78       	mov	r8,7
80003350:	f0 09 19 00 	cp.h	r9,r8
80003354:	c0 91       	brne	80003366 <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.callback =
80003356:	48 58       	lddpc	r8,80003368 <udi_cdc_comm_setup+0x78>
80003358:	48 69       	lddpc	r9,80003370 <udi_cdc_comm_setup+0x80>
8000335a:	91 49       	st.w	r8[0x10],r9
						udi_cdc_line_coding_receiveds[PORT];
				udd_g_ctrlreq.payload =
8000335c:	48 49       	lddpc	r9,8000336c <udi_cdc_comm_setup+0x7c>
8000335e:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding[PORT];
				udd_g_ctrlreq.payload_size =
80003360:	30 79       	mov	r9,7
80003362:	b0 69       	st.h	r8[0xc],r9
80003364:	5e ff       	retal	1
80003366:	5e fd       	retal	0
80003368:	00 00       	add	r0,r0
8000336a:	05 7c       	ld.ub	r12,--r2
8000336c:	00 00       	add	r0,r0
8000336e:	03 6c       	ld.uh	r12,--r1
80003370:	80 00       	ld.sh	r0,r0[0x0]
80003372:	37 a8       	mov	r8,122

80003374 <udi_cdc_data_setup>:
#endif

bool udi_cdc_data_setup(void)
{
	return false;  // request Not supported
}
80003374:	5e fd       	retal	0

80003376 <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
	return 0;      // CDC don't have multiple alternate setting
}
80003376:	5e fd       	retal	0

80003378 <udi_cdc_multi_is_rx_ready>:
}
#endif

bool udi_cdc_multi_is_rx_ready(uint8_t port)
{
	uint16_t pos = udi_cdc_rx_pos[PORT];
80003378:	48 68       	lddpc	r8,80003390 <udi_cdc_multi_is_rx_ready+0x18>
8000337a:	90 08       	ld.sh	r8,r8[0x0]
	return (pos < udi_cdc_rx_buf_nb[PORT][udi_cdc_rx_buf_sel[PORT]]);
8000337c:	48 69       	lddpc	r9,80003394 <udi_cdc_multi_is_rx_ready+0x1c>
8000337e:	13 8a       	ld.ub	r10,r9[0x0]
80003380:	48 69       	lddpc	r9,80003398 <udi_cdc_multi_is_rx_ready+0x20>
80003382:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80003386:	f0 09 19 00 	cp.h	r9,r8
}
8000338a:	5f bc       	srhi	r12
8000338c:	5e fc       	retal	r12
8000338e:	00 00       	add	r0,r0
80003390:	00 00       	add	r0,r0
80003392:	04 00       	add	r0,r2
80003394:	00 00       	add	r0,r0
80003396:	04 04       	add	r4,r2
80003398:	00 00       	add	r0,r0
8000339a:	03 fc       	ld.ub	r12,r1[0x7]

8000339c <udi_cdc_is_rx_ready>:

bool udi_cdc_is_rx_ready(void)
{
8000339c:	d4 01       	pushm	lr
	return udi_cdc_multi_is_rx_ready(0);
8000339e:	30 0c       	mov	r12,0
800033a0:	f0 1f 00 02 	mcall	800033a8 <udi_cdc_is_rx_ready+0xc>
}
800033a4:	d8 02       	popm	pc
800033a6:	00 00       	add	r0,r0
800033a8:	80 00       	ld.sh	r0,r0[0x0]
800033aa:	33 78       	mov	r8,55

800033ac <udi_cdc_multi_is_tx_ready>:
}

bool udi_cdc_multi_is_tx_ready(uint8_t port)
{
	irqflags_t flags;
	if (udi_cdc_tx_buf_nb[PORT][udi_cdc_tx_buf_sel[PORT]]!=UDI_CDC_TX_BUFFERS) {
800033ac:	49 58       	lddpc	r8,80003400 <udi_cdc_multi_is_tx_ready+0x54>
800033ae:	11 89       	ld.ub	r9,r8[0x0]
800033b0:	49 58       	lddpc	r8,80003404 <udi_cdc_multi_is_tx_ready+0x58>
800033b2:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800033b6:	34 08       	mov	r8,64
800033b8:	f0 09 19 00 	cp.h	r9,r8
800033bc:	c0 20       	breq	800033c0 <udi_cdc_multi_is_tx_ready+0x14>
800033be:	5e ff       	retal	1
		return true;
	}
	if (!udi_cdc_tx_both_buf_to_send[PORT]) {
800033c0:	49 28       	lddpc	r8,80003408 <udi_cdc_multi_is_tx_ready+0x5c>
800033c2:	11 88       	ld.ub	r8,r8[0x0]
800033c4:	58 08       	cp.w	r8,0
800033c6:	c1 21       	brne	800033ea <udi_cdc_multi_is_tx_ready+0x3e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800033c8:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800033cc:	d3 03       	ssrf	0x10
		flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
		if (!udi_cdc_tx_trans_ongoing[PORT]) {
800033ce:	49 09       	lddpc	r9,8000340c <udi_cdc_multi_is_tx_ready+0x60>
800033d0:	13 89       	ld.ub	r9,r9[0x0]
800033d2:	58 09       	cp.w	r9,0
800033d4:	c0 91       	brne	800033e6 <udi_cdc_multi_is_tx_ready+0x3a>
			// No transfer on-going
			// then use the other buffer to store data
			udi_cdc_tx_both_buf_to_send[PORT] = true;
800033d6:	30 1a       	mov	r10,1
800033d8:	48 c9       	lddpc	r9,80003408 <udi_cdc_multi_is_tx_ready+0x5c>
800033da:	b2 8a       	st.b	r9[0x0],r10
			udi_cdc_tx_buf_sel[PORT] = (udi_cdc_tx_buf_sel[PORT]==0)?1:0;
800033dc:	48 99       	lddpc	r9,80003400 <udi_cdc_multi_is_tx_ready+0x54>
800033de:	13 8a       	ld.ub	r10,r9[0x0]
800033e0:	58 0a       	cp.w	r10,0
800033e2:	5f 0a       	sreq	r10
800033e4:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800033e6:	e3 b8 00 00 	mtsr	0x0,r8
		}
	  	cpu_irq_restore(flags);
	}
	return (udi_cdc_tx_buf_nb[PORT][udi_cdc_tx_buf_sel[PORT]]!=UDI_CDC_TX_BUFFERS);
800033ea:	48 68       	lddpc	r8,80003400 <udi_cdc_multi_is_tx_ready+0x54>
800033ec:	11 89       	ld.ub	r9,r8[0x0]
800033ee:	48 68       	lddpc	r8,80003404 <udi_cdc_multi_is_tx_ready+0x58>
800033f0:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800033f4:	34 08       	mov	r8,64
800033f6:	f0 09 19 00 	cp.h	r9,r8
800033fa:	5f 1c       	srne	r12
}
800033fc:	5e fc       	retal	r12
800033fe:	00 00       	add	r0,r0
80003400:	00 00       	add	r0,r0
80003402:	03 74       	ld.ub	r4,--r1
80003404:	00 00       	add	r0,r0
80003406:	03 78       	ld.ub	r8,--r1
80003408:	00 00       	add	r0,r0
8000340a:	04 a0       	st.w	r2++,r0
8000340c:	00 00       	add	r0,r0
8000340e:	04 0c       	add	r12,r2

80003410 <udi_cdc_multi_putc>:
{
	return udi_cdc_multi_is_tx_ready(0);
}

int udi_cdc_multi_putc(uint8_t port, int value)
{
80003410:	eb cd 40 fe 	pushm	r1-r7,lr
80003414:	16 96       	mov	r6,r11
	irqflags_t flags;
	bool b_databit_9;
	uint8_t buf_sel;

	b_databit_9 = (9 == udi_cdc_line_coding[PORT].bDataBits);
80003416:	49 88       	lddpc	r8,80003474 <udi_cdc_multi_putc+0x64>
80003418:	11 e9       	ld.ub	r9,r8[0x6]
8000341a:	30 98       	mov	r8,9
8000341c:	f0 09 18 00 	cp.b	r9,r8
80003420:	5f 03       	sreq	r3

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_multi_is_tx_ready(PORT)) {
80003422:	30 07       	mov	r7,0
		if (!udi_cdc_running[PORT]) {
80003424:	49 55       	lddpc	r5,80003478 <udi_cdc_multi_putc+0x68>
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel[PORT];
80003426:	49 62       	lddpc	r2,8000347c <udi_cdc_multi_putc+0x6c>
	udi_cdc_tx_buf[PORT][buf_sel][udi_cdc_tx_buf_nb[PORT][buf_sel]++] = value;
80003428:	49 64       	lddpc	r4,80003480 <udi_cdc_multi_putc+0x70>
8000342a:	49 71       	lddpc	r1,80003484 <udi_cdc_multi_putc+0x74>

	b_databit_9 = (9 == udi_cdc_line_coding[PORT].bDataBits);

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_multi_is_tx_ready(PORT)) {
8000342c:	0e 9c       	mov	r12,r7
8000342e:	f0 1f 00 17 	mcall	80003488 <udi_cdc_multi_putc+0x78>
80003432:	c0 51       	brne	8000343c <udi_cdc_multi_putc+0x2c>
		if (!udi_cdc_running[PORT]) {
80003434:	0b 88       	ld.ub	r8,r5[0x0]
80003436:	58 08       	cp.w	r8,0
80003438:	cf a1       	brne	8000342c <udi_cdc_multi_putc+0x1c>
8000343a:	c1 b8       	rjmp	80003470 <udi_cdc_multi_putc+0x60>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000343c:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80003440:	d3 03       	ssrf	0x10
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel[PORT];
80003442:	05 88       	ld.ub	r8,r2[0x0]
	udi_cdc_tx_buf[PORT][buf_sel][udi_cdc_tx_buf_nb[PORT][buf_sel]++] = value;
80003444:	e8 08 04 19 	ld.sh	r9,r4[r8<<0x1]
80003448:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10
8000344c:	f0 0c 15 06 	lsl	r12,r8,0x6
80003450:	f8 0b 00 0b 	add	r11,r12,r11
80003454:	e2 0b 0b 06 	st.b	r1[r11],r6
80003458:	2f f9       	sub	r9,-1
8000345a:	e8 08 0a 19 	st.h	r4[r8<<0x1],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000345e:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);

	if (b_databit_9) {
80003462:	58 03       	cp.w	r3,0
80003464:	c0 31       	brne	8000346a <udi_cdc_multi_putc+0x5a>
80003466:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
8000346a:	a9 46       	asr	r6,0x8
8000346c:	0e 93       	mov	r3,r7
8000346e:	cd fb       	rjmp	8000342c <udi_cdc_multi_putc+0x1c>
		goto udi_cdc_putc_process_one_byte;
80003470:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80003474:	00 00       	add	r0,r0
80003476:	03 6c       	ld.uh	r12,--r1
80003478:	00 00       	add	r0,r0
8000347a:	04 08       	add	r8,r2
8000347c:	00 00       	add	r0,r0
8000347e:	03 74       	ld.ub	r4,--r1
80003480:	00 00       	add	r0,r0
80003482:	03 78       	ld.ub	r8,--r1
80003484:	00 00       	add	r0,r0
80003486:	03 7c       	ld.ub	r12,--r1
80003488:	80 00       	ld.sh	r0,r0[0x0]
8000348a:	33 ac       	mov	r12,58

8000348c <udi_cdc_putc>:
	}
	return true;
}

int udi_cdc_putc(int value)
{
8000348c:	d4 01       	pushm	lr
	return udi_cdc_multi_putc(0, value);
8000348e:	18 9b       	mov	r11,r12
80003490:	30 0c       	mov	r12,0
80003492:	f0 1f 00 02 	mcall	80003498 <udi_cdc_putc+0xc>
}
80003496:	d8 02       	popm	pc
80003498:	80 00       	ld.sh	r0,r0[0x0]
8000349a:	34 10       	mov	r0,65

8000349c <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(uint8_t port)
{
8000349c:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800034a0:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800034a4:	d3 03       	ssrf	0x10
	irqflags_t flags;
	uint8_t buf_sel_trans;

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel[PORT];
800034a6:	49 98       	lddpc	r8,80003508 <udi_cdc_rx_start+0x6c>
800034a8:	11 87       	ld.ub	r7,r8[0x0]
	if (udi_cdc_rx_trans_ongoing[PORT] ||
800034aa:	49 98       	lddpc	r8,8000350c <udi_cdc_rx_start+0x70>
800034ac:	11 88       	ld.ub	r8,r8[0x0]
800034ae:	58 08       	cp.w	r8,0
800034b0:	c0 a1       	brne	800034c4 <udi_cdc_rx_start+0x28>
		(udi_cdc_rx_pos[PORT] < udi_cdc_rx_buf_nb[PORT][buf_sel_trans])) {
800034b2:	49 88       	lddpc	r8,80003510 <udi_cdc_rx_start+0x74>
800034b4:	90 08       	ld.sh	r8,r8[0x0]
800034b6:	49 8a       	lddpc	r10,80003514 <udi_cdc_rx_start+0x78>
800034b8:	f4 07 04 1a 	ld.sh	r10,r10[r7<<0x1]
800034bc:	f0 0a 19 00 	cp.h	r10,r8
800034c0:	e0 88 00 06 	brls	800034cc <udi_cdc_rx_start+0x30>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800034c4:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
800034c8:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		cpu_irq_restore(flags);
		return false;
	}

	// Change current buffer
	udi_cdc_rx_pos[PORT] = 0;
800034cc:	30 0a       	mov	r10,0
800034ce:	49 18       	lddpc	r8,80003510 <udi_cdc_rx_start+0x74>
800034d0:	b0 0a       	st.h	r8[0x0],r10
	udi_cdc_rx_buf_sel[PORT] = (buf_sel_trans==0)?1:0;
800034d2:	58 07       	cp.w	r7,0
800034d4:	5f 0a       	sreq	r10
800034d6:	48 d8       	lddpc	r8,80003508 <udi_cdc_rx_start+0x6c>
800034d8:	b0 8a       	st.b	r8[0x0],r10

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing[PORT] = true;
800034da:	30 1a       	mov	r10,1
800034dc:	48 c8       	lddpc	r8,8000350c <udi_cdc_rx_start+0x70>
800034de:	b0 8a       	st.b	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800034e0:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);

	if (udi_cdc_multi_is_rx_ready(PORT)) {
800034e4:	30 0c       	mov	r12,0
800034e6:	f0 1f 00 0d 	mcall	80003518 <udi_cdc_rx_start+0x7c>
800034ea:	c0 30       	breq	800034f0 <udi_cdc_rx_start+0x54>
#if UDI_CDC_PORT_NB == 1
		UDI_CDC_RX_NOTIFY();
800034ec:	f0 1f 00 0c 	mcall	8000351c <udi_cdc_rx_start+0x80>
#else
		UDI_CDC_RX_NOTIFY(port);
#endif
	}

	return udd_ep_run( UDI_CDC_DATA_EP_OUTS[PORT],
800034f0:	a7 67       	lsl	r7,0x6
800034f2:	48 c8       	lddpc	r8,80003520 <udi_cdc_rx_start+0x84>
800034f4:	34 09       	mov	r9,64
800034f6:	48 ca       	lddpc	r10,80003524 <udi_cdc_rx_start+0x88>
800034f8:	0e 0a       	add	r10,r7
800034fa:	30 1b       	mov	r11,1
800034fc:	30 2c       	mov	r12,2
800034fe:	f0 1f 00 0b 	mcall	80003528 <udi_cdc_rx_start+0x8c>
			true,
			udi_cdc_rx_buf[PORT][buf_sel_trans],
			UDI_CDC_RX_BUFFERS,
			udi_cdc_data_received_callbacks[PORT]);
}
80003502:	e3 cd 80 80 	ldm	sp++,r7,pc
80003506:	00 00       	add	r0,r0
80003508:	00 00       	add	r0,r0
8000350a:	04 04       	add	r4,r2
8000350c:	00 00       	add	r0,r0
8000350e:	04 9c       	mov	r12,r2
80003510:	00 00       	add	r0,r0
80003512:	04 00       	add	r0,r2
80003514:	00 00       	add	r0,r0
80003516:	03 fc       	ld.ub	r12,r1[0x7]
80003518:	80 00       	ld.sh	r0,r0[0x0]
8000351a:	33 78       	mov	r8,55
8000351c:	80 00       	ld.sh	r0,r0[0x0]
8000351e:	3e f6       	mov	r6,-17
80003520:	80 00       	ld.sh	r0,r0[0x0]
80003522:	35 b4       	mov	r4,91
80003524:	00 00       	add	r0,r0
80003526:	04 1c       	sub	r12,r2
80003528:	80 00       	ld.sh	r0,r0[0x0]
8000352a:	2f 98       	sub	r8,-7

8000352c <udi_cdc_multi_getc>:
{
	return udi_cdc_multi_is_rx_ready(0);
}

int udi_cdc_multi_getc(uint8_t port)
{
8000352c:	d4 31       	pushm	r0-r7,lr
	int rx_data = 0;
	bool b_databit_9;
	uint16_t pos;
	uint8_t buf_sel;

	b_databit_9 = (9 == udi_cdc_line_coding[PORT].bDataBits);
8000352e:	49 78       	lddpc	r8,80003588 <udi_cdc_multi_getc+0x5c>
80003530:	11 e9       	ld.ub	r9,r8[0x6]
80003532:	30 98       	mov	r8,9
80003534:	f0 09 18 00 	cp.b	r9,r8
80003538:	5f 02       	sreq	r2
8000353a:	30 03       	mov	r3,0

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	pos = udi_cdc_rx_pos[PORT];
8000353c:	49 47       	lddpc	r7,8000358c <udi_cdc_multi_getc+0x60>
	buf_sel = udi_cdc_rx_buf_sel[PORT];
8000353e:	49 55       	lddpc	r5,80003590 <udi_cdc_multi_getc+0x64>
	while (pos >= udi_cdc_rx_buf_nb[PORT][buf_sel]) {
80003540:	49 56       	lddpc	r6,80003594 <udi_cdc_multi_getc+0x68>
		if (!udi_cdc_running[PORT]) {
80003542:	49 64       	lddpc	r4,80003598 <udi_cdc_multi_getc+0x6c>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[PORT][buf_sel][pos];
80003544:	49 60       	lddpc	r0,8000359c <udi_cdc_multi_getc+0x70>
	udi_cdc_rx_pos[PORT] = pos+1;

	udi_cdc_rx_start(PORT);
80003546:	06 91       	mov	r1,r3

	b_databit_9 = (9 == udi_cdc_line_coding[PORT].bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	pos = udi_cdc_rx_pos[PORT];
80003548:	8e 08       	ld.sh	r8,r7[0x0]
	buf_sel = udi_cdc_rx_buf_sel[PORT];
8000354a:	0b 89       	ld.ub	r9,r5[0x0]
	while (pos >= udi_cdc_rx_buf_nb[PORT][buf_sel]) {
8000354c:	ec 09 04 1a 	ld.sh	r10,r6[r9<<0x1]
80003550:	f0 0a 19 00 	cp.h	r10,r8
80003554:	e0 8b 00 06 	brhi	80003560 <udi_cdc_multi_getc+0x34>
		if (!udi_cdc_running[PORT]) {
80003558:	09 88       	ld.ub	r8,r4[0x0]
8000355a:	58 08       	cp.w	r8,0
8000355c:	cf 61       	brne	80003548 <udi_cdc_multi_getc+0x1c>
8000355e:	c1 28       	rjmp	80003582 <udi_cdc_multi_getc+0x56>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[PORT][buf_sel][pos];
80003560:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003564:	a7 69       	lsl	r9,0x6
80003566:	14 09       	add	r9,r10
80003568:	e0 09 07 09 	ld.ub	r9,r0[r9]
8000356c:	12 43       	or	r3,r9
	udi_cdc_rx_pos[PORT] = pos+1;
8000356e:	2f f8       	sub	r8,-1
80003570:	ae 08       	st.h	r7[0x0],r8

	udi_cdc_rx_start(PORT);
80003572:	02 9c       	mov	r12,r1
80003574:	f0 1f 00 0b 	mcall	800035a0 <udi_cdc_multi_getc+0x74>

	if (b_databit_9) {
80003578:	58 02       	cp.w	r2,0
8000357a:	c0 50       	breq	80003584 <udi_cdc_multi_getc+0x58>
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
8000357c:	a9 63       	lsl	r3,0x8
8000357e:	02 92       	mov	r2,r1
80003580:	ce 4b       	rjmp	80003548 <udi_cdc_multi_getc+0x1c>
		goto udi_cdc_getc_process_one_byte;
80003582:	30 03       	mov	r3,0
	}
	return rx_data;
}
80003584:	06 9c       	mov	r12,r3
80003586:	d8 32       	popm	r0-r7,pc
80003588:	00 00       	add	r0,r0
8000358a:	03 6c       	ld.uh	r12,--r1
8000358c:	00 00       	add	r0,r0
8000358e:	04 00       	add	r0,r2
80003590:	00 00       	add	r0,r0
80003592:	04 04       	add	r4,r2
80003594:	00 00       	add	r0,r0
80003596:	03 fc       	ld.ub	r12,r1[0x7]
80003598:	00 00       	add	r0,r0
8000359a:	04 08       	add	r8,r2
8000359c:	00 00       	add	r0,r0
8000359e:	04 1c       	sub	r12,r2
800035a0:	80 00       	ld.sh	r0,r0[0x0]
800035a2:	34 9c       	mov	r12,73

800035a4 <udi_cdc_getc>:

int udi_cdc_getc(void)
{
800035a4:	d4 01       	pushm	lr
	return udi_cdc_multi_getc(0);
800035a6:	30 0c       	mov	r12,0
800035a8:	f0 1f 00 02 	mcall	800035b0 <udi_cdc_getc+0xc>
}
800035ac:	d8 02       	popm	pc
800035ae:	00 00       	add	r0,r0
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	35 2c       	mov	r12,82

800035b4 <udi_cdc_data_received>:
			udi_cdc_data_received_callbacks[PORT]);
}


static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n)
{
800035b4:	d4 01       	pushm	lr

static void udi_cdc_data_received_common(uint8_t port, udd_ep_status_t status, iram_size_t n)
{
	uint8_t buf_sel_trans;

	if (UDD_EP_TRANSFER_OK != status) {
800035b6:	58 0c       	cp.w	r12,0
800035b8:	c1 c1       	brne	800035f0 <udi_cdc_data_received+0x3c>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[PORT]==0)?1:0;
800035ba:	48 f8       	lddpc	r8,800035f4 <udi_cdc_data_received+0x40>
800035bc:	11 88       	ld.ub	r8,r8[0x0]
800035be:	58 08       	cp.w	r8,0
800035c0:	5f 0a       	sreq	r10
	if (!n) {
800035c2:	58 0b       	cp.w	r11,0
800035c4:	c0 d1       	brne	800035de <udi_cdc_data_received+0x2a>
		udd_ep_run( UDI_CDC_DATA_EP_OUTS[PORT],
800035c6:	a7 6a       	lsl	r10,0x6
800035c8:	fe c8 00 14 	sub	r8,pc,20
800035cc:	34 09       	mov	r9,64
800035ce:	48 bb       	lddpc	r11,800035f8 <udi_cdc_data_received+0x44>
800035d0:	f6 0a 00 0a 	add	r10,r11,r10
800035d4:	30 1b       	mov	r11,1
800035d6:	30 2c       	mov	r12,2
800035d8:	f0 1f 00 09 	mcall	800035fc <udi_cdc_data_received+0x48>
800035dc:	d8 02       	popm	pc
				udi_cdc_rx_buf[PORT][buf_sel_trans],
				UDI_CDC_RX_BUFFERS,
				udi_cdc_data_received_callbacks[PORT]);
		return;
	}
	udi_cdc_rx_buf_nb[PORT][buf_sel_trans] = n;
800035de:	48 98       	lddpc	r8,80003600 <udi_cdc_data_received+0x4c>
800035e0:	f0 0a 0a 1b 	st.h	r8[r10<<0x1],r11
	udi_cdc_rx_trans_ongoing[PORT] = false;
800035e4:	30 09       	mov	r9,0
800035e6:	48 88       	lddpc	r8,80003604 <udi_cdc_data_received+0x50>
800035e8:	b0 89       	st.b	r8[0x0],r9
	udi_cdc_rx_start(PORT);
800035ea:	30 0c       	mov	r12,0
800035ec:	f0 1f 00 07 	mcall	80003608 <udi_cdc_data_received+0x54>
800035f0:	d8 02       	popm	pc
800035f2:	00 00       	add	r0,r0
800035f4:	00 00       	add	r0,r0
800035f6:	04 04       	add	r4,r2
800035f8:	00 00       	add	r0,r0
800035fa:	04 1c       	sub	r12,r2
800035fc:	80 00       	ld.sh	r0,r0[0x0]
800035fe:	2f 98       	sub	r8,-7
80003600:	00 00       	add	r0,r0
80003602:	03 fc       	ld.ub	r12,r1[0x7]
80003604:	00 00       	add	r0,r0
80003606:	04 9c       	mov	r12,r2
80003608:	80 00       	ld.sh	r0,r0[0x0]
8000360a:	34 9c       	mov	r12,73

8000360c <udi_cdc_tx_send>:
	udi_cdc_tx_send(PORT);
}


static void udi_cdc_tx_send(uint8_t port)
{
8000360c:	eb cd 40 e0 	pushm	r5-r7,lr
	irqflags_t flags;
	uint8_t buf_sel_trans;
	bool b_short_packet;

	if (udi_cdc_tx_trans_ongoing[PORT]) {
80003610:	4a a8       	lddpc	r8,800036b8 <udi_cdc_tx_send+0xac>
80003612:	11 88       	ld.ub	r8,r8[0x0]
80003614:	58 08       	cp.w	r8,0
80003616:	c4 f1       	brne	800036b4 <udi_cdc_tx_send+0xa8>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
80003618:	f0 1f 00 29 	mcall	800036bc <udi_cdc_tx_send+0xb0>
8000361c:	c0 a0       	breq	80003630 <udi_cdc_tx_send+0x24>
		if (udi_cdc_tx_sof_num[PORT] == udd_get_micro_frame_number()) {
8000361e:	4a 98       	lddpc	r8,800036c0 <udi_cdc_tx_send+0xb4>
80003620:	90 07       	ld.sh	r7,r8[0x0]
80003622:	f0 1f 00 29 	mcall	800036c4 <udi_cdc_tx_send+0xb8>
80003626:	f8 07 19 00 	cp.h	r7,r12
8000362a:	c0 a1       	brne	8000363e <udi_cdc_tx_send+0x32>
8000362c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num[PORT] == udd_get_frame_number()) {
80003630:	4a 48       	lddpc	r8,800036c0 <udi_cdc_tx_send+0xb4>
80003632:	90 07       	ld.sh	r7,r8[0x0]
80003634:	f0 1f 00 25 	mcall	800036c8 <udi_cdc_tx_send+0xbc>
80003638:	f8 07 19 00 	cp.h	r7,r12
8000363c:	c3 c0       	breq	800036b4 <udi_cdc_tx_send+0xa8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000363e:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80003642:	d3 03       	ssrf	0x10
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel[PORT];
80003644:	4a 29       	lddpc	r9,800036cc <udi_cdc_tx_send+0xc0>
80003646:	13 87       	ld.ub	r7,r9[0x0]
	if (!udi_cdc_tx_both_buf_to_send[PORT]) {
80003648:	4a 29       	lddpc	r9,800036d0 <udi_cdc_tx_send+0xc4>
8000364a:	13 89       	ld.ub	r9,r9[0x0]
8000364c:	58 09       	cp.w	r9,0
8000364e:	c0 61       	brne	8000365a <udi_cdc_tx_send+0x4e>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel[PORT] = (buf_sel_trans==0)?1:0;
80003650:	58 07       	cp.w	r7,0
80003652:	5f 0a       	sreq	r10
80003654:	49 e9       	lddpc	r9,800036cc <udi_cdc_tx_send+0xc0>
80003656:	b2 8a       	st.b	r9[0x0],r10
80003658:	c0 38       	rjmp	8000365e <udi_cdc_tx_send+0x52>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
8000365a:	58 07       	cp.w	r7,0
8000365c:	5f 07       	sreq	r7
	}
	udi_cdc_tx_trans_ongoing[PORT] = true;
8000365e:	30 1a       	mov	r10,1
80003660:	49 69       	lddpc	r9,800036b8 <udi_cdc_tx_send+0xac>
80003662:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003664:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	b_short_packet = (udi_cdc_tx_buf_nb[PORT][buf_sel_trans] != UDI_CDC_TX_BUFFERS);
80003668:	0e 95       	mov	r5,r7
8000366a:	49 b8       	lddpc	r8,800036d4 <udi_cdc_tx_send+0xc8>
8000366c:	f0 07 04 19 	ld.sh	r9,r8[r7<<0x1]
80003670:	34 08       	mov	r8,64
80003672:	f0 09 19 00 	cp.h	r9,r8
80003676:	5f 16       	srne	r6
	if (b_short_packet) {
80003678:	58 06       	cp.w	r6,0
8000367a:	c0 e0       	breq	80003696 <udi_cdc_tx_send+0x8a>
		if (udd_is_high_speed()) {
8000367c:	f0 1f 00 10 	mcall	800036bc <udi_cdc_tx_send+0xb0>
80003680:	c0 60       	breq	8000368c <udi_cdc_tx_send+0x80>
			udi_cdc_tx_sof_num[PORT] = udd_get_micro_frame_number();
80003682:	f0 1f 00 11 	mcall	800036c4 <udi_cdc_tx_send+0xb8>
80003686:	48 f8       	lddpc	r8,800036c0 <udi_cdc_tx_send+0xb4>
80003688:	b0 0c       	st.h	r8[0x0],r12
8000368a:	c0 98       	rjmp	8000369c <udi_cdc_tx_send+0x90>
		}else{
			udi_cdc_tx_sof_num[PORT] = udd_get_frame_number();
8000368c:	f0 1f 00 0f 	mcall	800036c8 <udi_cdc_tx_send+0xbc>
80003690:	48 c8       	lddpc	r8,800036c0 <udi_cdc_tx_send+0xb4>
80003692:	b0 0c       	st.h	r8[0x0],r12
80003694:	c0 48       	rjmp	8000369c <udi_cdc_tx_send+0x90>
		}
	}else{
		udi_cdc_tx_sof_num[PORT] = 0; // Force next transfer without wait SOF
80003696:	30 09       	mov	r9,0
80003698:	48 a8       	lddpc	r8,800036c0 <udi_cdc_tx_send+0xb4>
8000369a:	b0 09       	st.h	r8[0x0],r9
	}

	// Send the buffer with enable of short packet
	udd_ep_run( UDI_CDC_DATA_EP_INS[PORT],
8000369c:	a7 67       	lsl	r7,0x6
8000369e:	48 f8       	lddpc	r8,800036d8 <udi_cdc_tx_send+0xcc>
800036a0:	48 d9       	lddpc	r9,800036d4 <udi_cdc_tx_send+0xc8>
800036a2:	f2 05 05 19 	ld.uh	r9,r9[r5<<0x1]
800036a6:	48 ea       	lddpc	r10,800036dc <udi_cdc_tx_send+0xd0>
800036a8:	0e 0a       	add	r10,r7
800036aa:	0c 9b       	mov	r11,r6
800036ac:	e0 6c 00 81 	mov	r12,129
800036b0:	f0 1f 00 0c 	mcall	800036e0 <udi_cdc_tx_send+0xd4>
800036b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800036b8:	00 00       	add	r0,r0
800036ba:	04 0c       	add	r12,r2
800036bc:	80 00       	ld.sh	r0,r0[0x0]
800036be:	23 7e       	sub	lr,55
800036c0:	00 00       	add	r0,r0
800036c2:	04 02       	add	r2,r2
800036c4:	80 00       	ld.sh	r0,r0[0x0]
800036c6:	23 ba       	sub	r10,59
800036c8:	80 00       	ld.sh	r0,r0[0x0]
800036ca:	23 ae       	sub	lr,58
800036cc:	00 00       	add	r0,r0
800036ce:	03 74       	ld.ub	r4,--r1
800036d0:	00 00       	add	r0,r0
800036d2:	04 a0       	st.w	r2++,r0
800036d4:	00 00       	add	r0,r0
800036d6:	03 78       	ld.ub	r8,--r1
800036d8:	80 00       	ld.sh	r0,r0[0x0]
800036da:	36 f4       	mov	r4,111
800036dc:	00 00       	add	r0,r0
800036de:	03 7c       	ld.ub	r12,--r1
800036e0:	80 00       	ld.sh	r0,r0[0x0]
800036e2:	2f 98       	sub	r8,-7

800036e4 <udi_cdc_data_sof_notify>:
{
	return 0;      // CDC don't have multiple alternate setting
}

void udi_cdc_data_sof_notify(void)
{
800036e4:	d4 01       	pushm	lr
	udi_cdc_tx_send(0);
800036e6:	30 0c       	mov	r12,0
800036e8:	f0 1f 00 02 	mcall	800036f0 <udi_cdc_data_sof_notify+0xc>
}
800036ec:	d8 02       	popm	pc
800036ee:	00 00       	add	r0,r0
800036f0:	80 00       	ld.sh	r0,r0[0x0]
800036f2:	36 0c       	mov	r12,96

800036f4 <udi_cdc_data_sent>:
	udi_cdc_rx_start(PORT);
}


static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n)
{
800036f4:	d4 01       	pushm	lr
}
#endif

static void udi_cdc_data_sent_common(uint8_t port, udd_ep_status_t status, iram_size_t n)
{
	if (UDD_EP_TRANSFER_OK != status) {
800036f6:	58 0c       	cp.w	r12,0
800036f8:	c1 21       	brne	8000371c <udi_cdc_data_sent+0x28>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[PORT][(udi_cdc_tx_buf_sel[PORT]==0)?1:0] = 0;
800036fa:	48 a8       	lddpc	r8,80003720 <udi_cdc_data_sent+0x2c>
800036fc:	11 88       	ld.ub	r8,r8[0x0]
800036fe:	58 08       	cp.w	r8,0
80003700:	f9 b9 01 00 	movne	r9,0
80003704:	f9 b9 00 02 	moveq	r9,2
80003708:	30 08       	mov	r8,0
8000370a:	48 7a       	lddpc	r10,80003724 <udi_cdc_data_sent+0x30>
8000370c:	f4 09 0a 08 	st.h	r10[r9],r8
	udi_cdc_tx_both_buf_to_send[PORT] = false;
80003710:	48 69       	lddpc	r9,80003728 <udi_cdc_data_sent+0x34>
80003712:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_trans_ongoing[PORT] = false;
80003714:	48 69       	lddpc	r9,8000372c <udi_cdc_data_sent+0x38>
80003716:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_send(PORT);
80003718:	f0 1f 00 06 	mcall	80003730 <udi_cdc_data_sent+0x3c>
8000371c:	d8 02       	popm	pc
8000371e:	00 00       	add	r0,r0
80003720:	00 00       	add	r0,r0
80003722:	03 74       	ld.ub	r4,--r1
80003724:	00 00       	add	r0,r0
80003726:	03 78       	ld.ub	r8,--r1
80003728:	00 00       	add	r0,r0
8000372a:	04 a0       	st.w	r2++,r0
8000372c:	00 00       	add	r0,r0
8000372e:	04 0c       	add	r12,r2
80003730:	80 00       	ld.sh	r0,r0[0x0]
80003732:	36 0c       	mov	r12,96

80003734 <udi_cdc_data_enable>:
	udi_cdc_running[PORT] = udi_cdc_rx_start(PORT);
	return udi_cdc_running[PORT];
}

bool udi_cdc_data_enable(void)
{
80003734:	eb cd 40 c0 	pushm	r6-r7,lr
#endif

static bool udi_cdc_data_enable_common(uint8_t port)
{
	// Initialize TX management
	udi_cdc_tx_trans_ongoing[PORT] = false;
80003738:	30 06       	mov	r6,0
8000373a:	49 08       	lddpc	r8,80003778 <udi_cdc_data_enable+0x44>
8000373c:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_both_buf_to_send[PORT] = false;
8000373e:	49 08       	lddpc	r8,8000377c <udi_cdc_data_enable+0x48>
80003740:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_sel[PORT] = 0;
80003742:	49 08       	lddpc	r8,80003780 <udi_cdc_data_enable+0x4c>
80003744:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_nb[PORT][0] = 0;
80003746:	49 08       	lddpc	r8,80003784 <udi_cdc_data_enable+0x50>
80003748:	30 07       	mov	r7,0
8000374a:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_buf_nb[PORT][1] = 0;
8000374c:	b0 17       	st.h	r8[0x2],r7
	udi_cdc_tx_sof_num[PORT] = 0;
8000374e:	48 f8       	lddpc	r8,80003788 <udi_cdc_data_enable+0x54>
80003750:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_send(PORT);
80003752:	30 0c       	mov	r12,0
80003754:	f0 1f 00 0e 	mcall	8000378c <udi_cdc_data_enable+0x58>

	// Initialize RX management
	udi_cdc_rx_trans_ongoing[PORT] = false;
80003758:	48 e8       	lddpc	r8,80003790 <udi_cdc_data_enable+0x5c>
8000375a:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_sel[PORT] = 0;
8000375c:	48 e8       	lddpc	r8,80003794 <udi_cdc_data_enable+0x60>
8000375e:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_nb[PORT][0] = 0;
80003760:	48 e8       	lddpc	r8,80003798 <udi_cdc_data_enable+0x64>
80003762:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_rx_pos[PORT] = 0;
80003764:	48 e8       	lddpc	r8,8000379c <udi_cdc_data_enable+0x68>
80003766:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_running[PORT] = udi_cdc_rx_start(PORT);
80003768:	30 0c       	mov	r12,0
8000376a:	f0 1f 00 0e 	mcall	800037a0 <udi_cdc_data_enable+0x6c>
8000376e:	48 e8       	lddpc	r8,800037a4 <udi_cdc_data_enable+0x70>
80003770:	b0 8c       	st.b	r8[0x0],r12
	return udi_cdc_running[PORT];
80003772:	11 8c       	ld.ub	r12,r8[0x0]
}

bool udi_cdc_data_enable(void)
{
	return udi_cdc_data_enable_common(0);
}
80003774:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003778:	00 00       	add	r0,r0
8000377a:	04 0c       	add	r12,r2
8000377c:	00 00       	add	r0,r0
8000377e:	04 a0       	st.w	r2++,r0
80003780:	00 00       	add	r0,r0
80003782:	03 74       	ld.ub	r4,--r1
80003784:	00 00       	add	r0,r0
80003786:	03 78       	ld.ub	r8,--r1
80003788:	00 00       	add	r0,r0
8000378a:	04 02       	add	r2,r2
8000378c:	80 00       	ld.sh	r0,r0[0x0]
8000378e:	36 0c       	mov	r12,96
80003790:	00 00       	add	r0,r0
80003792:	04 9c       	mov	r12,r2
80003794:	00 00       	add	r0,r0
80003796:	04 04       	add	r4,r2
80003798:	00 00       	add	r0,r0
8000379a:	03 fc       	ld.ub	r12,r1[0x7]
8000379c:	00 00       	add	r0,r0
8000379e:	04 00       	add	r0,r2
800037a0:	80 00       	ld.sh	r0,r0[0x0]
800037a2:	34 9c       	mov	r12,73
800037a4:	00 00       	add	r0,r0
800037a6:	04 08       	add	r8,r2

800037a8 <udi_cdc_line_coding_received>:
//-------------------------------------------------
//------- Internal routines to control serial line


static void udi_cdc_line_coding_received(void)
{
800037a8:	d4 01       	pushm	lr
#endif
static void udi_cdc_line_coding_received_common(uint8_t port)
{
	// Send line coding to component associated to CDC
#if UDI_CDC_PORT_NB == 1
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding[0]));
800037aa:	48 3c       	lddpc	r12,800037b4 <udi_cdc_line_coding_received+0xc>
800037ac:	f0 1f 00 03 	mcall	800037b8 <udi_cdc_line_coding_received+0x10>


static void udi_cdc_line_coding_received(void)
{
	udi_cdc_line_coding_received_common(0);
}
800037b0:	d8 02       	popm	pc
800037b2:	00 00       	add	r0,r0
800037b4:	00 00       	add	r0,r0
800037b6:	03 6c       	ld.uh	r12,--r1
800037b8:	80 00       	ld.sh	r0,r0[0x0]
800037ba:	3e fe       	mov	lr,-17

800037bc <udi_cdc_comm_disable>:
	UDI_CDC_DISABLE_EXT(port);
#endif
}

void udi_cdc_comm_disable(void)
{
800037bc:	d4 01       	pushm	lr


static void udi_cdc_comm_disable_common(uint8_t port)
{
#if UDI_CDC_PORT_NB == 1
	udi_cdc_running[0] = false;
800037be:	30 09       	mov	r9,0
800037c0:	48 38       	lddpc	r8,800037cc <udi_cdc_comm_disable+0x10>
800037c2:	b0 89       	st.b	r8[0x0],r9
	UDI_CDC_DISABLE_EXT();
800037c4:	f0 1f 00 03 	mcall	800037d0 <udi_cdc_comm_disable+0x14>
}

void udi_cdc_comm_disable(void)
{
	udi_cdc_comm_disable_common(0);
}
800037c8:	d8 02       	popm	pc
800037ca:	00 00       	add	r0,r0
800037cc:	00 00       	add	r0,r0
800037ce:	04 08       	add	r8,r2
800037d0:	80 00       	ld.sh	r0,r0[0x0]
800037d2:	3f 00       	mov	r0,-16

800037d4 <udi_cdc_comm_enable>:
	return UDI_CDC_ENABLE_EXT(port);
#endif
}

bool udi_cdc_comm_enable(void)
{
800037d4:	d4 01       	pushm	lr


static bool udi_cdc_comm_enable_common(uint8_t port)
{
	// Initialize control signal management
	udi_cdc_state[PORT] = CPU_TO_LE16(0);
800037d6:	30 09       	mov	r9,0
800037d8:	48 f8       	lddpc	r8,80003814 <udi_cdc_comm_enable+0x40>
800037da:	b0 09       	st.h	r8[0x0],r9

	uid_cdc_state_msg[PORT].header.bmRequestType =
800037dc:	48 f8       	lddpc	r8,80003818 <udi_cdc_comm_enable+0x44>
800037de:	3a 1a       	mov	r10,-95
800037e0:	b0 8a       	st.b	r8[0x0],r10
			USB_REQ_DIR_IN | USB_REQ_TYPE_CLASS |
			USB_REQ_RECIP_INTERFACE,
	uid_cdc_state_msg[PORT].header.bNotification = USB_REQ_CDC_NOTIFY_SERIAL_STATE,
800037e2:	32 0a       	mov	r10,32
800037e4:	b0 9a       	st.b	r8[0x1],r10
	uid_cdc_state_msg[PORT].header.wValue = LE16(0),
800037e6:	b0 19       	st.h	r8[0x2],r9
	uid_cdc_state_msg[PORT].header.wIndex = LE16(UDI_CDC_COMM_IFACE_NUMBER),
800037e8:	b0 29       	st.h	r8[0x4],r9
	uid_cdc_state_msg[PORT].header.wLength = LE16(2),
800037ea:	e0 6a 02 00 	mov	r10,512
800037ee:	b0 3a       	st.h	r8[0x6],r10
	uid_cdc_state_msg[PORT].value = CPU_TO_LE16(0);
800037f0:	b0 49       	st.h	r8[0x8],r9

	udi_cdc_line_coding[PORT].dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
800037f2:	48 bc       	lddpc	r12,8000381c <udi_cdc_comm_enable+0x48>
800037f4:	30 08       	mov	r8,0
800037f6:	b8 89       	st.b	r12[0x0],r9
800037f8:	3c 29       	mov	r9,-62
800037fa:	b8 99       	st.b	r12[0x1],r9
800037fc:	30 19       	mov	r9,1
800037fe:	b8 a9       	st.b	r12[0x2],r9
80003800:	b8 b8       	st.b	r12[0x3],r8
	udi_cdc_line_coding[PORT].bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
80003802:	b8 c8       	st.b	r12[0x4],r8
	udi_cdc_line_coding[PORT].bParityType = UDI_CDC_DEFAULT_PARITY;
80003804:	b8 d8       	st.b	r12[0x5],r8
	udi_cdc_line_coding[PORT].bDataBits = UDI_CDC_DEFAULT_DATABITS;
80003806:	30 88       	mov	r8,8
80003808:	b8 e8       	st.b	r12[0x6],r8
	// Call application callback
	// to initialize memories or indicate that interface is enabled
#if UDI_CDC_PORT_NB == 1
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding[0]));
8000380a:	f0 1f 00 06 	mcall	80003820 <udi_cdc_comm_enable+0x4c>
	return UDI_CDC_ENABLE_EXT();
8000380e:	f0 1f 00 06 	mcall	80003824 <udi_cdc_comm_enable+0x50>
}

bool udi_cdc_comm_enable(void)
{
	return udi_cdc_comm_enable_common(0);
}
80003812:	d8 02       	popm	pc
80003814:	00 00       	add	r0,r0
80003816:	04 a4       	st.w	r2++,r4
80003818:	00 00       	add	r0,r0
8000381a:	04 10       	sub	r0,r2
8000381c:	00 00       	add	r0,r0
8000381e:	03 6c       	ld.uh	r12,--r1
80003820:	80 00       	ld.sh	r0,r0[0x0]
80003822:	3e fe       	mov	lr,-17
80003824:	80 00       	ld.sh	r0,r0[0x0]
80003826:	3f 24       	mov	r4,-14

80003828 <udc_sof_notify>:
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}

void udc_sof_notify(void)
{
80003828:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
8000382c:	49 18       	lddpc	r8,80003870 <udc_sof_notify+0x48>
8000382e:	11 89       	ld.ub	r9,r8[0x0]
80003830:	30 08       	mov	r8,0
80003832:	f0 09 18 00 	cp.b	r9,r8
80003836:	c1 b0       	breq	8000386c <udc_sof_notify+0x44>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003838:	48 f8       	lddpc	r8,80003874 <udc_sof_notify+0x4c>
8000383a:	70 08       	ld.w	r8,r8[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
8000383c:	70 09       	ld.w	r9,r8[0x0]
8000383e:	13 ca       	ld.ub	r10,r9[0x4]
80003840:	30 09       	mov	r9,0
80003842:	f2 0a 18 00 	cp.b	r10,r9
80003846:	c1 30       	breq	8000386c <udc_sof_notify+0x44>
80003848:	30 07       	mov	r7,0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
8000384a:	48 b6       	lddpc	r6,80003874 <udc_sof_notify+0x4c>
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
8000384c:	70 18       	ld.w	r8,r8[0x4]
8000384e:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
80003852:	70 48       	ld.w	r8,r8[0x10]
80003854:	58 08       	cp.w	r8,0
80003856:	c0 20       	breq	8000385a <udc_sof_notify+0x32>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
80003858:	5d 18       	icall	r8
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
8000385a:	2f f7       	sub	r7,-1
8000385c:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
8000385e:	6c 08       	ld.w	r8,r6[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
80003860:	70 09       	ld.w	r9,r8[0x0]
80003862:	13 c9       	ld.ub	r9,r9[0x4]
80003864:	ee 09 18 00 	cp.b	r9,r7
80003868:	fe 9b ff f2 	brhi	8000384c <udc_sof_notify+0x24>
8000386c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003870:	00 00       	add	r0,r0
80003872:	04 b0       	st.h	r2++,r0
80003874:	00 00       	add	r0,r0
80003876:	04 a8       	st.w	r2++,r8

80003878 <udc_get_eof_conf>:
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
80003878:	48 78       	lddpc	r8,80003894 <udc_get_eof_conf+0x1c>
8000387a:	70 08       	ld.w	r8,r8[0x0]
8000387c:	70 08       	ld.w	r8,r8[0x0]
8000387e:	11 aa       	ld.ub	r10,r8[0x2]
80003880:	11 b9       	ld.ub	r9,r8[0x3]
80003882:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80003886:	5c c9       	swap.bh	r9
80003888:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
}
8000388c:	f0 0c 00 0c 	add	r12,r8,r12
80003890:	5e fc       	retal	r12
80003892:	00 00       	add	r0,r0
80003894:	00 00       	add	r0,r0
80003896:	04 a8       	st.w	r2++,r8

80003898 <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
80003898:	eb cd 40 e0 	pushm	r5-r7,lr
8000389c:	18 97       	mov	r7,r12
8000389e:	16 96       	mov	r6,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
800038a0:	49 b8       	lddpc	r8,8000390c <udc_update_iface_desc+0x74>
800038a2:	11 89       	ld.ub	r9,r8[0x0]
800038a4:	30 08       	mov	r8,0
800038a6:	f0 09 18 00 	cp.b	r9,r8
800038aa:	c2 f0       	breq	80003908 <udc_update_iface_desc+0x70>
		return false;
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
800038ac:	49 98       	lddpc	r8,80003910 <udc_update_iface_desc+0x78>
800038ae:	70 08       	ld.w	r8,r8[0x0]
800038b0:	70 08       	ld.w	r8,r8[0x0]
800038b2:	11 c9       	ld.ub	r9,r8[0x4]
800038b4:	18 9e       	mov	lr,r12
800038b6:	f8 09 18 00 	cp.b	r9,r12
800038ba:	e0 88 00 27 	brls	80003908 <udc_update_iface_desc+0x70>
		return false;
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
800038be:	49 65       	lddpc	r5,80003914 <udc_update_iface_desc+0x7c>
800038c0:	8b 08       	st.w	r5[0x0],r8
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
800038c2:	f0 1f 00 16 	mcall	80003918 <udc_update_iface_desc+0x80>
	while (ptr_end_desc >
800038c6:	6a 08       	ld.w	r8,r5[0x0]
800038c8:	10 3c       	cp.w	r12,r8
800038ca:	e0 88 00 1f 	brls	80003908 <udc_update_iface_desc+0x70>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
800038ce:	30 4b       	mov	r11,4
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
800038d0:	10 99       	mov	r9,r8
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
800038d2:	11 9a       	ld.ub	r10,r8[0x1]
800038d4:	f6 0a 18 00 	cp.b	r10,r11
800038d8:	c0 a1       	brne	800038ec <udc_update_iface_desc+0x54>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
800038da:	11 aa       	ld.ub	r10,r8[0x2]
800038dc:	0e 9e       	mov	lr,r7
800038de:	ee 0a 18 00 	cp.b	r10,r7
800038e2:	c0 51       	brne	800038ec <udc_update_iface_desc+0x54>
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
800038e4:	11 ba       	ld.ub	r10,r8[0x3]
800038e6:	ec 0a 18 00 	cp.b	r10,r6
800038ea:	c0 b0       	breq	80003900 <udc_update_iface_desc+0x68>
				return true; // Interface found
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
800038ec:	13 88       	ld.ub	r8,r9[0x0]
800038ee:	f2 08 00 08 	add	r8,r9,r8
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
800038f2:	10 3c       	cp.w	r12,r8
800038f4:	fe 9b ff ee 	brhi	800038d0 <udc_update_iface_desc+0x38>
800038f8:	48 79       	lddpc	r9,80003914 <udc_update_iface_desc+0x7c>
800038fa:	93 08       	st.w	r9[0x0],r8
800038fc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003900:	48 59       	lddpc	r9,80003914 <udc_update_iface_desc+0x7c>
80003902:	93 08       	st.w	r9[0x0],r8
80003904:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80003908:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000390c:	00 00       	add	r0,r0
8000390e:	04 b0       	st.h	r2++,r0
80003910:	00 00       	add	r0,r0
80003912:	04 a8       	st.w	r2++,r8
80003914:	00 00       	add	r0,r0
80003916:	04 b4       	st.h	r2++,r4
80003918:	80 00       	ld.sh	r0,r0[0x0]
8000391a:	38 78       	mov	r8,-121

8000391c <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
8000391c:	eb cd 40 c0 	pushm	r6-r7,lr
80003920:	18 96       	mov	r6,r12
80003922:	16 97       	mov	r7,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
80003924:	f0 1f 00 11 	mcall	80003968 <udc_next_desc_in_iface+0x4c>
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
80003928:	0d 88       	ld.ub	r8,r6[0x0]
8000392a:	10 06       	add	r6,r8
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
8000392c:	0c 3c       	cp.w	r12,r6
8000392e:	e0 88 00 19 	brls	80003960 <udc_next_desc_in_iface+0x44>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
80003932:	0d 98       	ld.ub	r8,r6[0x1]
80003934:	30 49       	mov	r9,4
80003936:	f2 08 18 00 	cp.b	r8,r9
8000393a:	c1 30       	breq	80003960 <udc_next_desc_in_iface+0x44>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
8000393c:	ee 08 18 00 	cp.b	r8,r7
80003940:	c0 a1       	brne	80003954 <udc_next_desc_in_iface+0x38>
80003942:	c1 08       	rjmp	80003962 <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
80003944:	0d 98       	ld.ub	r8,r6[0x1]
80003946:	f2 08 18 00 	cp.b	r8,r9
8000394a:	c0 b0       	breq	80003960 <udc_next_desc_in_iface+0x44>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
8000394c:	ee 08 18 00 	cp.b	r8,r7
80003950:	c0 31       	brne	80003956 <udc_next_desc_in_iface+0x3a>
80003952:	c0 88       	rjmp	80003962 <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
80003954:	30 49       	mov	r9,4
		}
		if (desc_id == desc->bDescriptorType) {
			return desc; // Specific descriptor found
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
80003956:	0d 88       	ld.ub	r8,r6[0x0]
80003958:	10 06       	add	r6,r8
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
8000395a:	0c 3c       	cp.w	r12,r6
8000395c:	fe 9b ff f4 	brhi	80003944 <udc_next_desc_in_iface+0x28>
80003960:	30 06       	mov	r6,0
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL; // No specific descriptor found
}
80003962:	0c 9c       	mov	r12,r6
80003964:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003968:	80 00       	ld.sh	r0,r0[0x0]
8000396a:	38 78       	mov	r8,-121

8000396c <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
8000396c:	d4 01       	pushm	lr
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
8000396e:	48 48       	lddpc	r8,8000397c <udc_valid_address+0x10>
80003970:	11 bc       	ld.ub	r12,r8[0x3]
80003972:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
80003976:	f0 1f 00 03 	mcall	80003980 <udc_valid_address+0x14>
}
8000397a:	d8 02       	popm	pc
8000397c:	00 00       	add	r0,r0
8000397e:	05 7c       	ld.ub	r12,--r2
80003980:	80 00       	ld.sh	r0,r0[0x0]
80003982:	23 80       	sub	r0,56

80003984 <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
80003984:	eb cd 40 e0 	pushm	r5-r7,lr
80003988:	18 95       	mov	r5,r12
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num)) {
8000398a:	f0 1f 00 12 	mcall	800039d0 <udc_iface_enable+0x4c>
8000398e:	c1 f0       	breq	800039cc <udc_iface_enable+0x48>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
80003990:	49 18       	lddpc	r8,800039d4 <udc_iface_enable+0x50>
80003992:	70 07       	ld.w	r7,r8[0x0]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
80003994:	30 56       	mov	r6,5
80003996:	0c 9b       	mov	r11,r6
80003998:	0e 9c       	mov	r12,r7
8000399a:	f0 1f 00 10 	mcall	800039d8 <udc_iface_enable+0x54>
8000399e:	18 97       	mov	r7,r12
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
800039a0:	c0 d0       	breq	800039ba <udc_iface_enable+0x36>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
				ep_desc->bmAttributes,
				le16_to_cpu
800039a2:	19 ca       	ld.ub	r10,r12[0x4]
800039a4:	19 d8       	ld.ub	r8,r12[0x5]
800039a6:	f1 ea 10 8a 	or	r10,r8,r10<<0x8
800039aa:	5c ca       	swap.bh	r10
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
800039ac:	5c 7a       	castu.h	r10
800039ae:	19 bb       	ld.ub	r11,r12[0x3]
800039b0:	19 ac       	ld.ub	r12,r12[0x2]
800039b2:	f0 1f 00 0b 	mcall	800039dc <udc_iface_enable+0x58>
800039b6:	cf 01       	brne	80003996 <udc_iface_enable+0x12>
800039b8:	c0 a8       	rjmp	800039cc <udc_iface_enable+0x48>
			return false;
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
800039ba:	48 a8       	lddpc	r8,800039e0 <udc_iface_enable+0x5c>
800039bc:	70 08       	ld.w	r8,r8[0x0]
800039be:	70 18       	ld.w	r8,r8[0x4]
800039c0:	f0 05 03 28 	ld.w	r8,r8[r5<<0x2]
800039c4:	70 0c       	ld.w	r12,r8[0x0]
800039c6:	5d 1c       	icall	r12
800039c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800039cc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800039d0:	80 00       	ld.sh	r0,r0[0x0]
800039d2:	38 98       	mov	r8,-119
800039d4:	00 00       	add	r0,r0
800039d6:	04 b4       	st.h	r2++,r4
800039d8:	80 00       	ld.sh	r0,r0[0x0]
800039da:	39 1c       	mov	r12,-111
800039dc:	80 00       	ld.sh	r0,r0[0x0]
800039de:	24 88       	sub	r8,72
800039e0:	00 00       	add	r0,r0
800039e2:	04 a8       	st.w	r2++,r8

800039e4 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
800039e4:	eb cd 40 e0 	pushm	r5-r7,lr
800039e8:	18 96       	mov	r6,r12
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface
	// to update udc_ptr_iface before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
800039ea:	18 97       	mov	r7,r12
800039ec:	30 0b       	mov	r11,0
800039ee:	f0 1f 00 12 	mcall	80003a34 <udc_iface_disable+0x50>
800039f2:	c1 e0       	breq	80003a2e <udc_iface_disable+0x4a>
		return false;
	}

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
800039f4:	49 18       	lddpc	r8,80003a38 <udc_iface_disable+0x54>
800039f6:	70 08       	ld.w	r8,r8[0x0]
800039f8:	70 18       	ld.w	r8,r8[0x4]
800039fa:	f0 06 03 25 	ld.w	r5,r8[r6<<0x2]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
800039fe:	6a 3c       	ld.w	r12,r5[0xc]
80003a00:	5d 1c       	icall	r12
80003a02:	18 9b       	mov	r11,r12
80003a04:	0c 9c       	mov	r12,r6
80003a06:	f0 1f 00 0c 	mcall	80003a34 <udc_iface_disable+0x50>
80003a0a:	c1 20       	breq	80003a2e <udc_iface_disable+0x4a>
	}

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
80003a0c:	48 c8       	lddpc	r8,80003a3c <udc_iface_disable+0x58>
80003a0e:	70 07       	ld.w	r7,r8[0x0]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
80003a10:	30 56       	mov	r6,5
80003a12:	0c 9b       	mov	r11,r6
80003a14:	0e 9c       	mov	r12,r7
80003a16:	f0 1f 00 0b 	mcall	80003a40 <udc_iface_disable+0x5c>
80003a1a:	18 97       	mov	r7,r12
					udc_next_desc_in_iface((UDC_DESC_STORAGE
					usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
80003a1c:	c0 50       	breq	80003a26 <udc_iface_disable+0x42>
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
80003a1e:	19 ac       	ld.ub	r12,r12[0x2]
80003a20:	f0 1f 00 09 	mcall	80003a44 <udc_iface_disable+0x60>
		}
80003a24:	cf 7b       	rjmp	80003a12 <udc_iface_disable+0x2e>
	}
#endif

	// Disable interface
	udi_api->disable();
80003a26:	6a 18       	ld.w	r8,r5[0x4]
80003a28:	5d 18       	icall	r8
80003a2a:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
	return true;
80003a2e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003a32:	00 00       	add	r0,r0
80003a34:	80 00       	ld.sh	r0,r0[0x0]
80003a36:	38 98       	mov	r8,-119
80003a38:	00 00       	add	r0,r0
80003a3a:	04 a8       	st.w	r2++,r8
80003a3c:	00 00       	add	r0,r0
80003a3e:	04 b4       	st.h	r2++,r4
80003a40:	80 00       	ld.sh	r0,r0[0x0]
80003a42:	39 1c       	mov	r12,-111
80003a44:	80 00       	ld.sh	r0,r0[0x0]
80003a46:	2a 80       	sub	r0,-88

80003a48 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device,
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
80003a48:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
80003a4c:	49 38       	lddpc	r8,80003a98 <udc_reset+0x50>
80003a4e:	11 89       	ld.ub	r9,r8[0x0]
80003a50:	30 08       	mov	r8,0
80003a52:	f0 09 18 00 	cp.b	r9,r8
80003a56:	c1 70       	breq	80003a84 <udc_reset+0x3c>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003a58:	49 18       	lddpc	r8,80003a9c <udc_reset+0x54>
80003a5a:	70 08       	ld.w	r8,r8[0x0]
80003a5c:	70 08       	ld.w	r8,r8[0x0]
80003a5e:	11 c9       	ld.ub	r9,r8[0x4]
80003a60:	30 08       	mov	r8,0
80003a62:	f0 09 18 00 	cp.b	r9,r8
80003a66:	c0 f0       	breq	80003a84 <udc_reset+0x3c>
80003a68:	30 07       	mov	r7,0
80003a6a:	48 d6       	lddpc	r6,80003a9c <udc_reset+0x54>
				iface_num++) {
			udc_iface_disable(iface_num);
80003a6c:	0e 9c       	mov	r12,r7
80003a6e:	f0 1f 00 0d 	mcall	80003aa0 <udc_reset+0x58>
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
80003a72:	2f f7       	sub	r7,-1
80003a74:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003a76:	6c 08       	ld.w	r8,r6[0x0]
80003a78:	70 08       	ld.w	r8,r8[0x0]
80003a7a:	11 c8       	ld.ub	r8,r8[0x4]
80003a7c:	ee 08 18 00 	cp.b	r8,r7
80003a80:	fe 9b ff f6 	brhi	80003a6c <udc_reset+0x24>
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
80003a84:	30 09       	mov	r9,0
80003a86:	48 58       	lddpc	r8,80003a98 <udc_reset+0x50>
80003a88:	b0 89       	st.b	r8[0x0],r9
	if (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
80003a8a:	e0 69 01 00 	mov	r9,256
80003a8e:	48 68       	lddpc	r8,80003aa4 <udc_reset+0x5c>
80003a90:	b0 09       	st.h	r8[0x0],r9
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
80003a92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003a96:	00 00       	add	r0,r0
80003a98:	00 00       	add	r0,r0
80003a9a:	04 b0       	st.h	r2++,r0
80003a9c:	00 00       	add	r0,r0
80003a9e:	04 a8       	st.w	r2++,r8
80003aa0:	80 00       	ld.sh	r0,r0[0x0]
80003aa2:	39 e4       	mov	r4,-98
80003aa4:	00 00       	add	r0,r0
80003aa6:	04 ae       	st.w	r2++,lr

80003aa8 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
80003aa8:	eb cd 40 e0 	pushm	r5-r7,lr
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
80003aac:	fe f8 03 f4 	ld.w	r8,pc[1012]
80003ab0:	30 09       	mov	r9,0
80003ab2:	b0 69       	st.h	r8[0xc],r9
	udd_g_ctrlreq.callback = NULL;
80003ab4:	30 0a       	mov	r10,0
80003ab6:	91 4a       	st.w	r8[0x10],r10
	udd_g_ctrlreq.over_under_run = NULL;
80003ab8:	91 5a       	st.w	r8[0x14],r10

	if (Udd_setup_is_in()) {
80003aba:	11 88       	ld.ub	r8,r8[0x0]
80003abc:	10 9a       	mov	r10,r8
80003abe:	f2 08 18 00 	cp.b	r8,r9
80003ac2:	c0 94       	brge	80003ad4 <udc_process_setup+0x2c>
		if (udd_g_ctrlreq.req.wLength == 0) {
80003ac4:	fe f9 03 dc 	ld.w	r9,pc[988]
80003ac8:	92 3b       	ld.sh	r11,r9[0x6]
80003aca:	30 09       	mov	r9,0
80003acc:	f2 0b 19 00 	cp.h	r11,r9
80003ad0:	e0 80 01 e6 	breq	80003e9c <udc_process_setup+0x3f4>
			return false; // Error from USB host
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
80003ad4:	10 99       	mov	r9,r8
80003ad6:	e2 19 00 60 	andl	r9,0x60,COH
80003ada:	e0 81 01 b5 	brne	80003e44 <udc_process_setup+0x39c>
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
	if (Udd_setup_is_in()) {
80003ade:	f2 0a 18 00 	cp.b	r10,r9
80003ae2:	e0 84 00 dd 	brge	80003c9c <udc_process_setup+0x1f4>
		// GET Standard Requests
		if (udd_g_ctrlreq.req.wLength == 0) {
80003ae6:	fe f9 03 ba 	ld.w	r9,pc[954]
80003aea:	92 39       	ld.sh	r9,r9[0x6]
80003aec:	58 09       	cp.w	r9,0
80003aee:	e0 80 01 ab 	breq	80003e44 <udc_process_setup+0x39c>
			return false; // Error for USB host
		}

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003af2:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003af6:	c7 a1       	brne	80003bea <udc_process_setup+0x142>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003af8:	fe fa 03 a8 	ld.w	r10,pc[936]
80003afc:	15 9a       	ld.ub	r10,r10[0x1]
80003afe:	30 6b       	mov	r11,6
80003b00:	f6 0a 18 00 	cp.b	r10,r11
80003b04:	c1 80       	breq	80003b34 <udc_process_setup+0x8c>
80003b06:	30 8b       	mov	r11,8
80003b08:	f6 0a 18 00 	cp.b	r10,r11
80003b0c:	c6 20       	breq	80003bd0 <udc_process_setup+0x128>
80003b0e:	30 0b       	mov	r11,0
80003b10:	f6 0a 18 00 	cp.b	r10,r11
80003b14:	c6 b1       	brne	80003bea <udc_process_setup+0x142>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
80003b16:	30 28       	mov	r8,2
80003b18:	f0 09 19 00 	cp.h	r9,r8
80003b1c:	c0 40       	breq	80003b24 <udc_process_setup+0x7c>
80003b1e:	30 0c       	mov	r12,0
80003b20:	e0 8f 01 8e 	bral	80003e3c <udc_process_setup+0x394>
		return false;
	}

	udd_set_setup_payload( (uint8_t *) & udc_device_status,
80003b24:	30 2b       	mov	r11,2
80003b26:	fe fc 03 7e 	ld.w	r12,pc[894]
80003b2a:	f0 1f 00 e0 	mcall	80003ea8 <udc_process_setup+0x400>
80003b2e:	30 1c       	mov	r12,1
80003b30:	e0 8f 01 86 	bral	80003e3c <udc_process_setup+0x394>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003b34:	fe f8 03 6c 	ld.w	r8,pc[876]
80003b38:	90 19       	ld.sh	r9,r8[0x2]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
80003b3a:	f2 08 16 08 	lsr	r8,r9,0x8
80003b3e:	30 2a       	mov	r10,2
80003b40:	f4 08 18 00 	cp.b	r8,r10
80003b44:	c1 00       	breq	80003b64 <udc_process_setup+0xbc>
80003b46:	30 3a       	mov	r10,3
80003b48:	f4 08 18 00 	cp.b	r8,r10
80003b4c:	c2 a0       	breq	80003ba0 <udc_process_setup+0xf8>
80003b4e:	30 19       	mov	r9,1
80003b50:	f2 08 18 00 	cp.b	r8,r9
80003b54:	c3 c1       	brne	80003bcc <udc_process_setup+0x124>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
80003b56:	fe f8 03 56 	ld.w	r8,pc[854]
80003b5a:	70 0c       	ld.w	r12,r8[0x0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
80003b5c:	19 8b       	ld.ub	r11,r12[0x0]
80003b5e:	f0 1f 00 d3 	mcall	80003ea8 <udc_process_setup+0x400>
80003b62:	c2 68       	rjmp	80003bae <udc_process_setup+0x106>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003b64:	5c 59       	castu.b	r9
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
80003b66:	fe f8 03 46 	ld.w	r8,pc[838]
80003b6a:	70 08       	ld.w	r8,r8[0x0]
80003b6c:	f1 38 00 11 	ld.ub	r8,r8[17]
80003b70:	f2 08 18 00 	cp.b	r8,r9
80003b74:	e0 88 00 2c 	brls	80003bcc <udc_process_setup+0x124>
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
80003b78:	fe f8 03 34 	ld.w	r8,pc[820]
80003b7c:	70 18       	ld.w	r8,r8[0x4]
80003b7e:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80003b82:	19 a9       	ld.ub	r9,r12[0x2]
80003b84:	19 b8       	ld.ub	r8,r12[0x3]
80003b86:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80003b8a:	5c c8       	swap.bh	r8
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
80003b8c:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80003b90:	f0 1f 00 c6 	mcall	80003ea8 <udc_process_setup+0x400>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
80003b94:	fe f8 03 0c 	ld.w	r8,pc[780]
80003b98:	70 28       	ld.w	r8,r8[0x8]
80003b9a:	30 29       	mov	r9,2
80003b9c:	b0 99       	st.b	r8[0x1],r9
80003b9e:	c0 88       	rjmp	80003bae <udc_process_setup+0x106>
	uint8_t i;
	const uint8_t *str;
	uint8_t str_length = 0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
80003ba0:	5c 59       	castu.b	r9
80003ba2:	c1 51       	brne	80003bcc <udc_process_setup+0x124>
	case 0:
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
80003ba4:	30 4b       	mov	r11,4
80003ba6:	fe fc 03 0a 	ld.w	r12,pc[778]
80003baa:	f0 1f 00 c0 	mcall	80003ea8 <udc_process_setup+0x400>
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
80003bae:	fe f8 02 f2 	ld.w	r8,pc[754]
80003bb2:	90 39       	ld.sh	r9,r8[0x6]
80003bb4:	90 68       	ld.sh	r8,r8[0xc]
80003bb6:	f2 08 19 00 	cp.h	r8,r9
80003bba:	e0 8b 00 04 	brhi	80003bc2 <udc_process_setup+0x11a>
80003bbe:	30 1c       	mov	r12,1
80003bc0:	c3 e9       	rjmp	80003e3c <udc_process_setup+0x394>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
80003bc2:	fe f8 02 de 	ld.w	r8,pc[734]
80003bc6:	b0 69       	st.h	r8[0xc],r9
80003bc8:	30 1c       	mov	r12,1
80003bca:	c3 99       	rjmp	80003e3c <udc_process_setup+0x394>
80003bcc:	30 0c       	mov	r12,0
80003bce:	c3 79       	rjmp	80003e3c <udc_process_setup+0x394>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1) {
80003bd0:	30 18       	mov	r8,1
80003bd2:	f0 09 19 00 	cp.h	r9,r8
80003bd6:	c0 30       	breq	80003bdc <udc_process_setup+0x134>
80003bd8:	30 0c       	mov	r12,0
80003bda:	c3 19       	rjmp	80003e3c <udc_process_setup+0x394>
		return false;
	}

	udd_set_setup_payload(&udc_num_configuration,1);
80003bdc:	30 1b       	mov	r11,1
80003bde:	fe fc 02 d6 	ld.w	r12,pc[726]
80003be2:	f0 1f 00 b2 	mcall	80003ea8 <udc_process_setup+0x400>
80003be6:	30 1c       	mov	r12,1
80003be8:	c2 a9       	rjmp	80003e3c <udc_process_setup+0x394>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003bea:	58 18       	cp.w	r8,1
80003bec:	c3 61       	brne	80003c58 <udc_process_setup+0x1b0>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003bee:	fe fa 02 b2 	ld.w	r10,pc[690]
80003bf2:	15 9b       	ld.ub	r11,r10[0x1]
80003bf4:	30 aa       	mov	r10,10
80003bf6:	f4 0b 18 00 	cp.b	r11,r10
80003bfa:	c2 f1       	brne	80003c58 <udc_process_setup+0x1b0>
{
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
80003bfc:	f0 09 19 00 	cp.h	r9,r8
80003c00:	c2 a1       	brne	80003c54 <udc_process_setup+0x1ac>
		return false; // Error in request
	}
	if (!udc_num_configuration) {
80003c02:	fe f8 02 b2 	ld.w	r8,pc[690]
80003c06:	11 89       	ld.ub	r9,r8[0x0]
80003c08:	30 08       	mov	r8,0
80003c0a:	f0 09 18 00 	cp.b	r9,r8
80003c0e:	c2 30       	breq	80003c54 <udc_process_setup+0x1ac>
		return false; // The device is not is configured state yet
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003c10:	fe f8 02 90 	ld.w	r8,pc[656]
80003c14:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
80003c16:	fe f8 02 a2 	ld.w	r8,pc[674]
80003c1a:	70 08       	ld.w	r8,r8[0x0]
80003c1c:	70 08       	ld.w	r8,r8[0x0]
80003c1e:	11 c8       	ld.ub	r8,r8[0x4]
80003c20:	ee 08 18 00 	cp.b	r8,r7
80003c24:	e0 88 00 18 	brls	80003c54 <udc_process_setup+0x1ac>
		return false;
	}

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
80003c28:	30 0b       	mov	r11,0
80003c2a:	0e 9c       	mov	r12,r7
80003c2c:	f0 1f 00 a4 	mcall	80003ebc <udc_process_setup+0x414>
80003c30:	c1 20       	breq	80003c54 <udc_process_setup+0x1ac>
		return false;
	}
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
	udc_iface_setting = udi_api->getsetting();
80003c32:	fe f8 02 86 	ld.w	r8,pc[646]
80003c36:	70 08       	ld.w	r8,r8[0x0]
80003c38:	70 18       	ld.w	r8,r8[0x4]
80003c3a:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
80003c3e:	70 3c       	ld.w	r12,r8[0xc]
80003c40:	5d 1c       	icall	r12
80003c42:	fe f8 02 7e 	ld.w	r8,pc[638]
80003c46:	b0 8c       	st.b	r8[0x0],r12

	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
80003c48:	30 1b       	mov	r11,1
80003c4a:	10 9c       	mov	r12,r8
80003c4c:	f0 1f 00 97 	mcall	80003ea8 <udc_process_setup+0x400>
80003c50:	30 1c       	mov	r12,1
80003c52:	cf 58       	rjmp	80003e3c <udc_process_setup+0x394>
80003c54:	30 0c       	mov	r12,0
80003c56:	cf 38       	rjmp	80003e3c <udc_process_setup+0x394>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003c58:	58 28       	cp.w	r8,2
80003c5a:	e0 81 00 f5 	brne	80003e44 <udc_process_setup+0x39c>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c5e:	fe f8 02 42 	ld.w	r8,pc[578]
80003c62:	11 9a       	ld.ub	r10,r8[0x1]
80003c64:	30 08       	mov	r8,0
80003c66:	f0 0a 18 00 	cp.b	r10,r8
80003c6a:	e0 81 00 e8 	brne	80003e3a <udc_process_setup+0x392>
 */
static bool udc_req_std_ep_get_status(void)
{
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
80003c6e:	30 28       	mov	r8,2
80003c70:	f0 09 19 00 	cp.h	r9,r8
80003c74:	c0 30       	breq	80003c7a <udc_process_setup+0x1d2>
80003c76:	30 0c       	mov	r12,0
80003c78:	ce 28       	rjmp	80003e3c <udc_process_setup+0x394>
		return false;
	}

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
80003c7a:	fe f8 02 26 	ld.w	r8,pc[550]
80003c7e:	11 dc       	ld.ub	r12,r8[0x5]
80003c80:	f0 1f 00 91 	mcall	80003ec4 <udc_process_setup+0x41c>
80003c84:	e0 68 01 00 	mov	r8,256
80003c88:	f9 b8 00 00 	moveq	r8,0
80003c8c:	fe fc 02 3c 	ld.w	r12,pc[572]
80003c90:	b8 08       	st.h	r12[0x0],r8
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
80003c92:	30 2b       	mov	r11,2
80003c94:	f0 1f 00 85 	mcall	80003ea8 <udc_process_setup+0x400>
80003c98:	30 1c       	mov	r12,1
80003c9a:	cd 18       	rjmp	80003e3c <udc_process_setup+0x394>
			}
		}
#endif
	} else {
		// SET Standard Requests
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003c9c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003ca0:	c7 71       	brne	80003d8e <udc_process_setup+0x2e6>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003ca2:	fe f9 01 fe 	ld.w	r9,pc[510]
80003ca6:	13 99       	ld.ub	r9,r9[0x1]
80003ca8:	30 3a       	mov	r10,3
80003caa:	f4 09 18 00 	cp.b	r9,r10
80003cae:	e0 80 00 c6 	breq	80003e3a <udc_process_setup+0x392>
80003cb2:	e0 8b 00 07 	brhi	80003cc0 <udc_process_setup+0x218>
80003cb6:	30 1a       	mov	r10,1
80003cb8:	f4 09 18 00 	cp.b	r9,r10
80003cbc:	c6 91       	brne	80003d8e <udc_process_setup+0x2e6>
80003cbe:	c1 78       	rjmp	80003cec <udc_process_setup+0x244>
80003cc0:	30 5a       	mov	r10,5
80003cc2:	f4 09 18 00 	cp.b	r9,r10
80003cc6:	c0 60       	breq	80003cd2 <udc_process_setup+0x22a>
80003cc8:	30 9a       	mov	r10,9
80003cca:	f4 09 18 00 	cp.b	r9,r10
80003cce:	c6 01       	brne	80003d8e <udc_process_setup+0x2e6>
80003cd0:	c2 28       	rjmp	80003d14 <udc_process_setup+0x26c>
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength) {
80003cd2:	4f 48       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003cd4:	90 39       	ld.sh	r9,r8[0x6]
80003cd6:	30 08       	mov	r8,0
80003cd8:	f0 09 19 00 	cp.h	r9,r8
80003cdc:	c0 30       	breq	80003ce2 <udc_process_setup+0x23a>
80003cde:	30 0c       	mov	r12,0
80003ce0:	ca e8       	rjmp	80003e3c <udc_process_setup+0x394>
		return false;
	}

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
80003ce2:	4f b9       	lddpc	r9,80003ecc <udc_process_setup+0x424>
80003ce4:	4e f8       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003ce6:	91 49       	st.w	r8[0x10],r9
80003ce8:	30 1c       	mov	r12,1
80003cea:	ca 98       	rjmp	80003e3c <udc_process_setup+0x394>
 *
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
80003cec:	4e d8       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003cee:	90 39       	ld.sh	r9,r8[0x6]
80003cf0:	30 08       	mov	r8,0
80003cf2:	f0 09 19 00 	cp.h	r9,r8
80003cf6:	c0 d1       	brne	80003d10 <udc_process_setup+0x268>
		return false;
	}

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
80003cf8:	4e a8       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003cfa:	90 19       	ld.sh	r9,r8[0x2]
80003cfc:	30 18       	mov	r8,1
80003cfe:	f0 09 19 00 	cp.h	r9,r8
80003d02:	c0 71       	brne	80003d10 <udc_process_setup+0x268>
		udc_device_status &= CPU_TO_LE16(~USB_DEV_STATUS_REMOTEWAKEUP);
80003d04:	4e 88       	lddpc	r8,80003ea4 <udc_process_setup+0x3fc>
80003d06:	90 09       	ld.sh	r9,r8[0x0]
80003d08:	a9 d9       	cbr	r9,0x9
80003d0a:	b0 09       	st.h	r8[0x0],r9
80003d0c:	30 1c       	mov	r12,1
80003d0e:	c9 78       	rjmp	80003e3c <udc_process_setup+0x394>
80003d10:	30 0c       	mov	r12,0
80003d12:	c9 58       	rjmp	80003e3c <udc_process_setup+0x394>
static bool udc_req_std_dev_set_configuration(void)
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
80003d14:	4e 38       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003d16:	90 39       	ld.sh	r9,r8[0x6]
80003d18:	30 08       	mov	r8,0
80003d1a:	f0 09 19 00 	cp.h	r9,r8
80003d1e:	c3 41       	brne	80003d86 <udc_process_setup+0x2de>
		return false;
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
80003d20:	f0 1f 00 6c 	mcall	80003ed0 <udc_process_setup+0x428>
80003d24:	c3 10       	breq	80003d86 <udc_process_setup+0x2de>
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80003d26:	4d f8       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003d28:	11 b9       	ld.ub	r9,r8[0x3]
80003d2a:	4e 18       	lddpc	r8,80003eac <udc_process_setup+0x404>
80003d2c:	70 08       	ld.w	r8,r8[0x0]
80003d2e:	f1 38 00 11 	ld.ub	r8,r8[17]
80003d32:	10 39       	cp.w	r9,r8
80003d34:	e0 89 00 29 	brgt	80003d86 <udc_process_setup+0x2de>
			return false;
		}
	}

	// Reset current configuration
	udc_reset();
80003d38:	f0 1f 00 67 	mcall	80003ed4 <udc_process_setup+0x42c>

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
80003d3c:	4d 98       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003d3e:	11 b8       	ld.ub	r8,r8[0x3]
80003d40:	4d d9       	lddpc	r9,80003eb4 <udc_process_setup+0x40c>
80003d42:	b2 88       	st.b	r9[0x0],r8
	if (udc_num_configuration == 0) {
80003d44:	58 08       	cp.w	r8,0
80003d46:	c2 20       	breq	80003d8a <udc_process_setup+0x2e2>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
80003d48:	20 18       	sub	r8,1
80003d4a:	4d 99       	lddpc	r9,80003eac <udc_process_setup+0x404>
80003d4c:	72 19       	ld.w	r9,r9[0x4]
80003d4e:	f2 08 00 38 	add	r8,r9,r8<<0x3
80003d52:	4d a9       	lddpc	r9,80003eb8 <udc_process_setup+0x410>
80003d54:	93 08       	st.w	r9[0x0],r8
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d56:	70 08       	ld.w	r8,r8[0x0]
80003d58:	11 c9       	ld.ub	r9,r8[0x4]
80003d5a:	30 08       	mov	r8,0
80003d5c:	f0 09 18 00 	cp.b	r9,r8
80003d60:	c1 50       	breq	80003d8a <udc_process_setup+0x2e2>
80003d62:	30 07       	mov	r7,0
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
80003d64:	0e 95       	mov	r5,r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d66:	4d 56       	lddpc	r6,80003eb8 <udc_process_setup+0x410>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
80003d68:	0a 9b       	mov	r11,r5
80003d6a:	0e 9c       	mov	r12,r7
80003d6c:	f0 1f 00 5b 	mcall	80003ed8 <udc_process_setup+0x430>
80003d70:	c0 b0       	breq	80003d86 <udc_process_setup+0x2de>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
80003d72:	2f f7       	sub	r7,-1
80003d74:	5c 57       	castu.b	r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d76:	6c 08       	ld.w	r8,r6[0x0]
80003d78:	70 08       	ld.w	r8,r8[0x0]
80003d7a:	11 c8       	ld.ub	r8,r8[0x4]
80003d7c:	ee 08 18 00 	cp.b	r8,r7
80003d80:	fe 9b ff f4 	brhi	80003d68 <udc_process_setup+0x2c0>
80003d84:	c0 38       	rjmp	80003d8a <udc_process_setup+0x2e2>
80003d86:	30 0c       	mov	r12,0
80003d88:	c5 a8       	rjmp	80003e3c <udc_process_setup+0x394>
80003d8a:	30 1c       	mov	r12,1
80003d8c:	c5 88       	rjmp	80003e3c <udc_process_setup+0x394>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003d8e:	58 18       	cp.w	r8,1
80003d90:	c2 21       	brne	80003dd4 <udc_process_setup+0x32c>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003d92:	4c 49       	lddpc	r9,80003ea0 <udc_process_setup+0x3f8>
80003d94:	13 9a       	ld.ub	r10,r9[0x1]
80003d96:	30 b9       	mov	r9,11
80003d98:	f2 0a 18 00 	cp.b	r10,r9
80003d9c:	c1 c1       	brne	80003dd4 <udc_process_setup+0x32c>
 */
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
80003d9e:	4c 18       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003da0:	90 39       	ld.sh	r9,r8[0x6]
80003da2:	30 08       	mov	r8,0
80003da4:	f0 09 19 00 	cp.h	r9,r8
80003da8:	c1 41       	brne	80003dd0 <udc_process_setup+0x328>
		return false; // Error in request
	}
	if (!udc_num_configuration) {
80003daa:	4c 38       	lddpc	r8,80003eb4 <udc_process_setup+0x40c>
80003dac:	11 89       	ld.ub	r9,r8[0x0]
80003dae:	30 08       	mov	r8,0
80003db0:	f0 09 18 00 	cp.b	r9,r8
80003db4:	c0 e0       	breq	80003dd0 <udc_process_setup+0x328>
		return false; // The device is not is configured state yet
	}

	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
80003db6:	4b b8       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003db8:	90 16       	ld.sh	r6,r8[0x2]

	// Disable current setting
	if (!udc_iface_disable(iface_num)) {
80003dba:	11 d7       	ld.ub	r7,r8[0x5]
80003dbc:	0e 9c       	mov	r12,r7
80003dbe:	f0 1f 00 48 	mcall	80003edc <udc_process_setup+0x434>
80003dc2:	c0 70       	breq	80003dd0 <udc_process_setup+0x328>
		return false;
	}

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
80003dc4:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80003dc8:	0e 9c       	mov	r12,r7
80003dca:	f0 1f 00 44 	mcall	80003ed8 <udc_process_setup+0x430>
80003dce:	c3 78       	rjmp	80003e3c <udc_process_setup+0x394>
80003dd0:	30 0c       	mov	r12,0
80003dd2:	c3 58       	rjmp	80003e3c <udc_process_setup+0x394>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003dd4:	58 28       	cp.w	r8,2
80003dd6:	c3 71       	brne	80003e44 <udc_process_setup+0x39c>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003dd8:	4b 28       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003dda:	11 98       	ld.ub	r8,r8[0x1]
80003ddc:	30 19       	mov	r9,1
80003dde:	f2 08 18 00 	cp.b	r8,r9
80003de2:	c0 60       	breq	80003dee <udc_process_setup+0x346>
80003de4:	30 39       	mov	r9,3
80003de6:	f2 08 18 00 	cp.b	r8,r9
80003dea:	c2 81       	brne	80003e3a <udc_process_setup+0x392>
80003dec:	c1 48       	rjmp	80003e14 <udc_process_setup+0x36c>
 *
 * \return true if success
 */
static bool udc_req_std_ep_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
80003dee:	4a d8       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003df0:	90 39       	ld.sh	r9,r8[0x6]
80003df2:	30 08       	mov	r8,0
80003df4:	f0 09 19 00 	cp.h	r9,r8
80003df8:	c0 c1       	brne	80003e10 <udc_process_setup+0x368>
		return false;
	}

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003dfa:	4a a8       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003dfc:	90 19       	ld.sh	r9,r8[0x2]
80003dfe:	30 08       	mov	r8,0
80003e00:	f0 09 19 00 	cp.h	r9,r8
80003e04:	c0 61       	brne	80003e10 <udc_process_setup+0x368>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003e06:	4a 78       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003e08:	11 dc       	ld.ub	r12,r8[0x5]
80003e0a:	f0 1f 00 36 	mcall	80003ee0 <udc_process_setup+0x438>
80003e0e:	c1 78       	rjmp	80003e3c <udc_process_setup+0x394>
80003e10:	30 0c       	mov	r12,0
80003e12:	c1 58       	rjmp	80003e3c <udc_process_setup+0x394>
 * \return true if success
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_epset_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
80003e14:	4a 38       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003e16:	90 39       	ld.sh	r9,r8[0x6]
80003e18:	30 08       	mov	r8,0
80003e1a:	f0 09 19 00 	cp.h	r9,r8
80003e1e:	c0 c1       	brne	80003e36 <udc_process_setup+0x38e>
		return false;
	}
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003e20:	4a 08       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003e22:	90 19       	ld.sh	r9,r8[0x2]
80003e24:	30 08       	mov	r8,0
80003e26:	f0 09 19 00 	cp.h	r9,r8
80003e2a:	c0 61       	brne	80003e36 <udc_process_setup+0x38e>
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003e2c:	49 d8       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003e2e:	11 dc       	ld.ub	r12,r8[0x5]
80003e30:	f0 1f 00 2d 	mcall	80003ee4 <udc_process_setup+0x43c>
80003e34:	c0 48       	rjmp	80003e3c <udc_process_setup+0x394>
80003e36:	30 0c       	mov	r12,0
80003e38:	c0 28       	rjmp	80003e3c <udc_process_setup+0x394>
80003e3a:	30 0c       	mov	r12,0
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd()) {
80003e3c:	58 0c       	cp.w	r12,0
80003e3e:	c0 30       	breq	80003e44 <udc_process_setup+0x39c>
80003e40:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
			return true;
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
80003e44:	49 78       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003e46:	11 88       	ld.ub	r8,r8[0x0]
80003e48:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e4c:	58 18       	cp.w	r8,1
80003e4e:	c2 71       	brne	80003e9c <udc_process_setup+0x3f4>
static bool udc_req_iface(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
80003e50:	49 98       	lddpc	r8,80003eb4 <udc_process_setup+0x40c>
80003e52:	11 89       	ld.ub	r9,r8[0x0]
80003e54:	30 08       	mov	r8,0
80003e56:	f0 09 18 00 	cp.b	r9,r8
80003e5a:	c2 10       	breq	80003e9c <udc_process_setup+0x3f4>
		return false; // The device is not is configured state yet
	}
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003e5c:	49 18       	lddpc	r8,80003ea0 <udc_process_setup+0x3f8>
80003e5e:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
80003e60:	49 68       	lddpc	r8,80003eb8 <udc_process_setup+0x410>
80003e62:	70 08       	ld.w	r8,r8[0x0]
80003e64:	70 08       	ld.w	r8,r8[0x0]
80003e66:	11 c8       	ld.ub	r8,r8[0x4]
80003e68:	ee 08 18 00 	cp.b	r8,r7
80003e6c:	e0 88 00 18 	brls	80003e9c <udc_process_setup+0x3f4>
	}

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
80003e70:	0e 96       	mov	r6,r7
80003e72:	30 0b       	mov	r11,0
80003e74:	0e 9c       	mov	r12,r7
80003e76:	f0 1f 00 12 	mcall	80003ebc <udc_process_setup+0x414>
80003e7a:	c1 10       	breq	80003e9c <udc_process_setup+0x3f4>
		return false;
	}
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80003e7c:	48 f8       	lddpc	r8,80003eb8 <udc_process_setup+0x410>
80003e7e:	70 08       	ld.w	r8,r8[0x0]
80003e80:	70 18       	ld.w	r8,r8[0x4]
80003e82:	f0 07 03 27 	ld.w	r7,r8[r7<<0x2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
80003e86:	6e 3c       	ld.w	r12,r7[0xc]
80003e88:	5d 1c       	icall	r12
80003e8a:	18 9b       	mov	r11,r12
80003e8c:	0c 9c       	mov	r12,r6
80003e8e:	f0 1f 00 0c 	mcall	80003ebc <udc_process_setup+0x414>
80003e92:	c0 50       	breq	80003e9c <udc_process_setup+0x3f4>
		return false;
	}

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
80003e94:	6e 2c       	ld.w	r12,r7[0x8]
80003e96:	5d 1c       	icall	r12
80003e98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e9c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003ea0:	00 00       	add	r0,r0
80003ea2:	05 7c       	ld.ub	r12,--r2
80003ea4:	00 00       	add	r0,r0
80003ea6:	04 ae       	st.w	r2++,lr
80003ea8:	80 00       	ld.sh	r0,r0[0x0]
80003eaa:	23 bc       	sub	r12,59
80003eac:	00 00       	add	r0,r0
80003eae:	00 84       	andn	r4,r0
80003eb0:	00 00       	add	r0,r0
80003eb2:	00 a0       	st.w	r0++,r0
80003eb4:	00 00       	add	r0,r0
80003eb6:	04 b0       	st.h	r2++,r0
80003eb8:	00 00       	add	r0,r0
80003eba:	04 a8       	st.w	r2++,r8
80003ebc:	80 00       	ld.sh	r0,r0[0x0]
80003ebe:	38 98       	mov	r8,-119
80003ec0:	00 00       	add	r0,r0
80003ec2:	04 a6       	st.w	r2++,r6
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	23 c8       	sub	r8,60
80003ec8:	00 00       	add	r0,r0
80003eca:	04 ac       	st.w	r2++,r12
80003ecc:	80 00       	ld.sh	r0,r0[0x0]
80003ece:	39 6c       	mov	r12,-106
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	23 a2       	sub	r2,58
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	3a 48       	mov	r8,-92
80003ed8:	80 00       	ld.sh	r0,r0[0x0]
80003eda:	39 84       	mov	r4,-104
80003edc:	80 00       	ld.sh	r0,r0[0x0]
80003ede:	39 e4       	mov	r4,-98
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	23 dc       	sub	r12,61
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	2a 50       	sub	r0,-91

80003ee8 <udc_start>:
}

/*! \brief Start the USB Device stack
 */
void udc_start(void)
{
80003ee8:	d4 01       	pushm	lr
	udd_enable();
80003eea:	f0 1f 00 02 	mcall	80003ef0 <udc_start+0x8>
}
80003eee:	d8 02       	popm	pc
80003ef0:	80 00       	ld.sh	r0,r0[0x0]
80003ef2:	30 84       	mov	r4,8

80003ef4 <usart_interrupt>:
static usart_options_t usart_options;


ISR(usart_interrupt, USART_IRQ_GROUP, 3)
{
}
80003ef4:	d6 03       	rete

80003ef6 <uart_rx_notify>:
}

void uart_rx_notify(void)
{
	// If UART is open
	if (USART->imr & AVR32_USART_IER_RXRDY_MASK) {
80003ef6:	fe 78 2c 00 	mov	r8,-54272
80003efa:	70 48       	ld.w	r8,r8[0x10]
	}
}
80003efc:	5e fc       	retal	r12

80003efe <uart_config>:
	default:
	case CDC_PAR_NONE:
		parity = USART_NO_PARITY;
		break;
	}
}
80003efe:	5e fc       	retal	r12

80003f00 <main_cdc_disable>:
	return true;
}

void main_cdc_disable(void)
{
	main_b_cdc_enable = false;
80003f00:	30 09       	mov	r9,0
80003f02:	48 28       	lddpc	r8,80003f08 <main_cdc_disable+0x8>
80003f04:	b0 89       	st.b	r8[0x0],r9
	// Close communication
	uart_close();
}
80003f06:	5e fc       	retal	r12
80003f08:	00 00       	add	r0,r0
80003f0a:	04 b8       	st.h	r2++,r8

80003f0c <uart_open>:
	}
}


void uart_open(void)
{
80003f0c:	d4 01       	pushm	lr
	// Enable interrupt with priority higher than USB
	irq_register_handler(usart_interrupt, USART_IRQ, 3);
80003f0e:	30 3a       	mov	r10,3
80003f10:	e0 6b 02 a0 	mov	r11,672
80003f14:	48 2c       	lddpc	r12,80003f1c <uart_open+0x10>
80003f16:	f0 1f 00 03 	mcall	80003f20 <uart_open+0x14>
}
80003f1a:	d8 02       	popm	pc
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	3e f4       	mov	r4,-17
80003f20:	80 00       	ld.sh	r0,r0[0x0]
80003f22:	22 70       	sub	r0,39

80003f24 <main_cdc_enable>:
		udc_detach();
	}
}

bool main_cdc_enable(void)
{
80003f24:	d4 01       	pushm	lr
	main_b_cdc_enable = true;
80003f26:	30 19       	mov	r9,1
80003f28:	48 38       	lddpc	r8,80003f34 <main_cdc_enable+0x10>
80003f2a:	b0 89       	st.b	r8[0x0],r9
	// Open communication
	uart_open();
80003f2c:	f0 1f 00 03 	mcall	80003f38 <main_cdc_enable+0x14>
	return true;
}
80003f30:	da 0a       	popm	pc,r12=1
80003f32:	00 00       	add	r0,r0
80003f34:	00 00       	add	r0,r0
80003f36:	04 b8       	st.h	r2++,r8
80003f38:	80 00       	ld.sh	r0,r0[0x0]
80003f3a:	3f 0c       	mov	r12,-16

80003f3c <main_vbus_action>:
	}
	
}

void main_vbus_action(bool b_high)
{
80003f3c:	d4 01       	pushm	lr
	if (b_high) {
80003f3e:	58 0c       	cp.w	r12,0
80003f40:	c0 40       	breq	80003f48 <main_vbus_action+0xc>
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
	udd_attach();
80003f42:	f0 1f 00 04 	mcall	80003f50 <main_vbus_action+0x14>
80003f46:	d8 02       	popm	pc
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
	udd_detach();
80003f48:	f0 1f 00 03 	mcall	80003f54 <main_vbus_action+0x18>
80003f4c:	d8 02       	popm	pc
80003f4e:	00 00       	add	r0,r0
80003f50:	80 00       	ld.sh	r0,r0[0x0]
80003f52:	25 8c       	sub	r12,88
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	25 64       	sub	r4,86

80003f58 <main>:
}

/*! \brief Main function. Execution starts here.
 */
int main(void)
{
80003f58:	eb cd 40 c0 	pushm	r6-r7,lr
	irq_initialize_vectors();
80003f5c:	f0 1f 00 17 	mcall	80003fb8 <main+0x60>
	cpu_irq_enable();
80003f60:	d5 03       	csrf	0x10
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t i;

	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
		sleepmgr_locks[i] = 0;
80003f62:	49 78       	lddpc	r8,80003fbc <main+0x64>
80003f64:	30 09       	mov	r9,0
80003f66:	b0 89       	st.b	r8[0x0],r9
80003f68:	b0 99       	st.b	r8[0x1],r9
80003f6a:	b0 a9       	st.b	r8[0x2],r9
80003f6c:	b0 b9       	st.b	r8[0x3],r9
80003f6e:	b0 c9       	st.b	r8[0x4],r9
80003f70:	b0 d9       	st.b	r8[0x5],r9
	}
	sleepmgr_locks[SLEEPMGR_NR_OF_MODES - 1] = 1;
80003f72:	30 19       	mov	r9,1
80003f74:	b0 e9       	st.b	r8[0x6],r9

	// Initialize the sleep manager
	sleepmgr_init();

	sysclk_init();
80003f76:	f0 1f 00 13 	mcall	80003fc0 <main+0x68>
	board_init();
80003f7a:	f0 1f 00 13 	mcall	80003fc4 <main+0x6c>
	
	
	delay_init(FOSC0);
80003f7e:	e0 6c 24 00 	mov	r12,9216
80003f82:	ea 1c 00 f4 	orh	r12,0xf4
80003f86:	f0 1f 00 11 	mcall	80003fc8 <main+0x70>
	// Start USB stack to authorize VBus monitoring
	udc_start();
80003f8a:	f0 1f 00 11 	mcall	80003fcc <main+0x74>
 *        udc_attach(); \n
 *     }  \n
 */
static inline bool udc_include_vbus_monitoring(void)
{
	return udd_include_vbus_monitoring();
80003f8e:	f0 1f 00 11 	mcall	80003fd0 <main+0x78>

	if (!udc_include_vbus_monitoring()) {
80003f92:	c0 41       	brne	80003f9a <main+0x42>
		// VBUS monitoring is not available on this product
		// thereby VBUS has to be considered as present
		main_vbus_action(true);
80003f94:	30 1c       	mov	r12,1
80003f96:	f0 1f 00 10 	mcall	80003fd4 <main+0x7c>
		if (udi_cdc_is_rx_ready()) {
			// Transmit next data
		
		}else{
			value = udi_cdc_getc();
			delay_ms(1);
80003f9a:	30 16       	mov	r6,1
	
	while (true) {
	
		int value;
		// Transfer UART RX fifo to CDC TX
		if (udi_cdc_is_rx_ready()) {
80003f9c:	f0 1f 00 0f 	mcall	80003fd8 <main+0x80>
80003fa0:	cf e1       	brne	80003f9c <main+0x44>
			// Transmit next data
		
		}else{
			value = udi_cdc_getc();
80003fa2:	f0 1f 00 0f 	mcall	80003fdc <main+0x84>
80003fa6:	18 97       	mov	r7,r12
			delay_ms(1);
80003fa8:	0c 9c       	mov	r12,r6
80003faa:	f0 1f 00 0e 	mcall	80003fe0 <main+0x88>
			udi_cdc_putc(value);
80003fae:	0e 9c       	mov	r12,r7
80003fb0:	f0 1f 00 0d 	mcall	80003fe4 <main+0x8c>
80003fb4:	cf 4b       	rjmp	80003f9c <main+0x44>
80003fb6:	00 00       	add	r0,r0
80003fb8:	80 00       	ld.sh	r0,r0[0x0]
80003fba:	22 f0       	sub	r0,47
80003fbc:	00 00       	add	r0,r0
80003fbe:	05 d4       	ld.ub	r4,r2[0x5]
80003fc0:	80 00       	ld.sh	r0,r0[0x0]
80003fc2:	32 72       	mov	r2,39
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	20 04       	sub	r4,0
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	31 80       	mov	r0,24
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	3e e8       	mov	r8,-18
80003fd0:	80 00       	ld.sh	r0,r0[0x0]
80003fd2:	23 7c       	sub	r12,55
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	3f 3c       	mov	r12,-13
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	33 9c       	mov	r12,57
80003fdc:	80 00       	ld.sh	r0,r0[0x0]
80003fde:	35 a4       	mov	r4,90
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	31 8c       	mov	r12,24
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	34 8c       	mov	r12,72

80003fe8 <__avr32_udiv64>:
80003fe8:	d4 31       	pushm	r0-r7,lr
80003fea:	1a 97       	mov	r7,sp
80003fec:	20 2d       	sub	sp,8
80003fee:	10 9e       	mov	lr,r8
80003ff0:	12 95       	mov	r5,r9
80003ff2:	14 96       	mov	r6,r10
80003ff4:	58 09       	cp.w	r9,0
80003ff6:	c4 91       	brne	80004088 <__avr32_udiv64+0xa0>
80003ff8:	16 38       	cp.w	r8,r11
80003ffa:	e0 88 00 57 	brls	800040a8 <__avr32_udiv64+0xc0>
80003ffe:	f0 08 12 00 	clz	r8,r8
80004002:	c0 d0       	breq	8000401c <__avr32_udiv64+0x34>
80004004:	f6 08 09 4b 	lsl	r11,r11,r8
80004008:	f0 09 11 20 	rsub	r9,r8,32
8000400c:	fc 08 09 4e 	lsl	lr,lr,r8
80004010:	f4 09 0a 49 	lsr	r9,r10,r9
80004014:	f4 08 09 46 	lsl	r6,r10,r8
80004018:	f3 eb 10 0b 	or	r11,r9,r11
8000401c:	fc 05 16 10 	lsr	r5,lr,0x10
80004020:	f9 de c0 10 	bfextu	r12,lr,0x0,0x10
80004024:	f6 05 0d 0a 	divu	r10,r11,r5
80004028:	ec 08 16 10 	lsr	r8,r6,0x10
8000402c:	14 99       	mov	r9,r10
8000402e:	f1 eb 11 08 	or	r8,r8,r11<<0x10
80004032:	b9 3a       	mul	r10,r12
80004034:	10 3a       	cp.w	r10,r8
80004036:	e0 88 00 0c 	brls	8000404e <__avr32_udiv64+0x66>
8000403a:	20 19       	sub	r9,1
8000403c:	1c 08       	add	r8,lr
8000403e:	10 3e       	cp.w	lr,r8
80004040:	e0 8b 00 07 	brhi	8000404e <__avr32_udiv64+0x66>
80004044:	10 3a       	cp.w	r10,r8
80004046:	f7 b9 0b 01 	subhi	r9,1
8000404a:	f1 de eb 08 	addhi	r8,r8,lr
8000404e:	f0 0a 01 0b 	sub	r11,r8,r10
80004052:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80004056:	f6 05 0d 0a 	divu	r10,r11,r5
8000405a:	ed eb 11 06 	or	r6,r6,r11<<0x10
8000405e:	14 98       	mov	r8,r10
80004060:	f4 0c 02 4c 	mul	r12,r10,r12
80004064:	0c 3c       	cp.w	r12,r6
80004066:	e0 88 00 0a 	brls	8000407a <__avr32_udiv64+0x92>
8000406a:	20 18       	sub	r8,1
8000406c:	1c 06       	add	r6,lr
8000406e:	0c 3e       	cp.w	lr,r6
80004070:	e0 8b 00 05 	brhi	8000407a <__avr32_udiv64+0x92>
80004074:	0c 3c       	cp.w	r12,r6
80004076:	f7 b8 0b 01 	subhi	r8,1
8000407a:	f1 e9 11 0b 	or	r11,r8,r9<<0x10
8000407e:	30 0c       	mov	r12,0
80004080:	16 9a       	mov	r10,r11
80004082:	18 9b       	mov	r11,r12
80004084:	2f ed       	sub	sp,-8
80004086:	d8 32       	popm	r0-r7,pc
80004088:	16 39       	cp.w	r9,r11
8000408a:	e0 8b 00 51 	brhi	8000412c <__avr32_udiv64+0x144>
8000408e:	f2 0c 12 00 	clz	r12,r9
80004092:	c5 31       	brne	80004138 <__avr32_udiv64+0x150>
80004094:	14 38       	cp.w	r8,r10
80004096:	5f 89       	srls	r9
80004098:	16 35       	cp.w	r5,r11
8000409a:	5f 38       	srlo	r8
8000409c:	10 49       	or	r9,r8
8000409e:	f8 09 18 00 	cp.b	r9,r12
800040a2:	c4 50       	breq	8000412c <__avr32_udiv64+0x144>
800040a4:	30 1b       	mov	r11,1
800040a6:	c4 58       	rjmp	80004130 <__avr32_udiv64+0x148>
800040a8:	58 08       	cp.w	r8,0
800040aa:	c0 51       	brne	800040b4 <__avr32_udiv64+0xcc>
800040ac:	30 19       	mov	r9,1
800040ae:	f2 08 0d 08 	divu	r8,r9,r8
800040b2:	10 9e       	mov	lr,r8
800040b4:	fc 08 12 00 	clz	r8,lr
800040b8:	e0 81 00 91 	brne	800041da <__avr32_udiv64+0x1f2>
800040bc:	1c 1b       	sub	r11,lr
800040be:	fc 05 16 10 	lsr	r5,lr,0x10
800040c2:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
800040c6:	30 1c       	mov	r12,1
800040c8:	f6 05 0d 0a 	divu	r10,r11,r5
800040cc:	ec 08 16 10 	lsr	r8,r6,0x10
800040d0:	f4 09 02 43 	mul	r3,r10,r9
800040d4:	f1 eb 11 08 	or	r8,r8,r11<<0x10
800040d8:	14 9b       	mov	r11,r10
800040da:	10 33       	cp.w	r3,r8
800040dc:	e0 88 00 0c 	brls	800040f4 <__avr32_udiv64+0x10c>
800040e0:	20 1b       	sub	r11,1
800040e2:	1c 08       	add	r8,lr
800040e4:	10 3e       	cp.w	lr,r8
800040e6:	e0 8b 00 07 	brhi	800040f4 <__avr32_udiv64+0x10c>
800040ea:	10 33       	cp.w	r3,r8
800040ec:	f7 bb 0b 01 	subhi	r11,1
800040f0:	f1 de eb 08 	addhi	r8,r8,lr
800040f4:	f0 03 01 03 	sub	r3,r8,r3
800040f8:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800040fc:	e6 05 0d 02 	divu	r2,r3,r5
80004100:	ed e3 11 06 	or	r6,r6,r3<<0x10
80004104:	04 98       	mov	r8,r2
80004106:	e4 09 02 49 	mul	r9,r2,r9
8000410a:	0c 39       	cp.w	r9,r6
8000410c:	e0 88 00 0a 	brls	80004120 <__avr32_udiv64+0x138>
80004110:	20 18       	sub	r8,1
80004112:	1c 06       	add	r6,lr
80004114:	0c 3e       	cp.w	lr,r6
80004116:	e0 8b 00 05 	brhi	80004120 <__avr32_udiv64+0x138>
8000411a:	0c 39       	cp.w	r9,r6
8000411c:	f7 b8 0b 01 	subhi	r8,1
80004120:	f1 eb 11 0b 	or	r11,r8,r11<<0x10
80004124:	16 9a       	mov	r10,r11
80004126:	18 9b       	mov	r11,r12
80004128:	2f ed       	sub	sp,-8
8000412a:	d8 32       	popm	r0-r7,pc
8000412c:	30 0b       	mov	r11,0
8000412e:	16 9c       	mov	r12,r11
80004130:	16 9a       	mov	r10,r11
80004132:	18 9b       	mov	r11,r12
80004134:	2f ed       	sub	sp,-8
80004136:	d8 32       	popm	r0-r7,pc
80004138:	f2 0c 09 45 	lsl	r5,r9,r12
8000413c:	f8 0e 11 20 	rsub	lr,r12,32
80004140:	f0 0c 09 43 	lsl	r3,r8,r12
80004144:	f4 0e 0a 46 	lsr	r6,r10,lr
80004148:	f0 0e 0a 48 	lsr	r8,r8,lr
8000414c:	f6 0e 0a 4e 	lsr	lr,r11,lr
80004150:	0a 48       	or	r8,r5
80004152:	f0 01 16 10 	lsr	r1,r8,0x10
80004156:	fc 01 0d 04 	divu	r4,lr,r1
8000415a:	ee e5 ff f8 	st.d	r7[-8],r4
8000415e:	f6 0c 09 49 	lsl	r9,r11,r12
80004162:	eb d8 c0 10 	bfextu	r5,r8,0x0,0x10
80004166:	ed e9 10 09 	or	r9,r6,r9
8000416a:	08 96       	mov	r6,r4
8000416c:	f2 0e 16 10 	lsr	lr,r9,0x10
80004170:	ee f4 ff f8 	ld.w	r4,r7[-8]
80004174:	ec 05 02 4b 	mul	r11,r6,r5
80004178:	fd e4 11 0e 	or	lr,lr,r4<<0x10
8000417c:	1c 3b       	cp.w	r11,lr
8000417e:	e0 88 00 07 	brls	8000418c <__avr32_udiv64+0x1a4>
80004182:	20 16       	sub	r6,1
80004184:	10 0e       	add	lr,r8
80004186:	1c 38       	cp.w	r8,lr
80004188:	e0 88 00 6d 	brls	80004262 <__avr32_udiv64+0x27a>
8000418c:	16 1e       	sub	lr,r11
8000418e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
80004192:	fc 01 0d 00 	divu	r0,lr,r1
80004196:	f3 e1 11 09 	or	r9,r9,r1<<0x10
8000419a:	00 9b       	mov	r11,r0
8000419c:	e0 05 02 4e 	mul	lr,r0,r5
800041a0:	12 3e       	cp.w	lr,r9
800041a2:	e0 88 00 07 	brls	800041b0 <__avr32_udiv64+0x1c8>
800041a6:	20 1b       	sub	r11,1
800041a8:	10 09       	add	r9,r8
800041aa:	12 38       	cp.w	r8,r9
800041ac:	e0 88 00 55 	brls	80004256 <__avr32_udiv64+0x26e>
800041b0:	f7 e6 11 0b 	or	r11,r11,r6<<0x10
800041b4:	1c 19       	sub	r9,lr
800041b6:	f6 03 06 42 	mulu.d	r2,r11,r3
800041ba:	06 39       	cp.w	r9,r3
800041bc:	c0 93       	brcs	800041ce <__avr32_udiv64+0x1e6>
800041be:	5f 09       	sreq	r9
800041c0:	f4 0c 09 4c 	lsl	r12,r10,r12
800041c4:	04 3c       	cp.w	r12,r2
800041c6:	5f 38       	srlo	r8
800041c8:	f3 e8 00 08 	and	r8,r9,r8
800041cc:	c0 20       	breq	800041d0 <__avr32_udiv64+0x1e8>
800041ce:	20 1b       	sub	r11,1
800041d0:	30 0c       	mov	r12,0
800041d2:	16 9a       	mov	r10,r11
800041d4:	18 9b       	mov	r11,r12
800041d6:	2f ed       	sub	sp,-8
800041d8:	d8 32       	popm	r0-r7,pc
800041da:	f6 08 09 49 	lsl	r9,r11,r8
800041de:	fc 08 09 4e 	lsl	lr,lr,r8
800041e2:	f0 01 11 20 	rsub	r1,r8,32
800041e6:	fc 05 16 10 	lsr	r5,lr,0x10
800041ea:	f4 01 0a 42 	lsr	r2,r10,r1
800041ee:	f6 01 0a 41 	lsr	r1,r11,r1
800041f2:	12 42       	or	r2,r9
800041f4:	e2 05 0d 00 	divu	r0,r1,r5
800041f8:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
800041fc:	e4 06 16 10 	lsr	r6,r2,0x10
80004200:	00 93       	mov	r3,r0
80004202:	ed e1 11 06 	or	r6,r6,r1<<0x10
80004206:	e0 09 02 4c 	mul	r12,r0,r9
8000420a:	0c 3c       	cp.w	r12,r6
8000420c:	e0 88 00 07 	brls	8000421a <__avr32_udiv64+0x232>
80004210:	20 13       	sub	r3,1
80004212:	1c 06       	add	r6,lr
80004214:	0c 3e       	cp.w	lr,r6
80004216:	e0 88 00 2c 	brls	8000426e <__avr32_udiv64+0x286>
8000421a:	ec 0c 01 01 	sub	r1,r6,r12
8000421e:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80004222:	e2 05 0d 00 	divu	r0,r1,r5
80004226:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000422a:	00 9c       	mov	r12,r0
8000422c:	e0 09 02 41 	mul	r1,r0,r9
80004230:	16 31       	cp.w	r1,r11
80004232:	e0 88 00 0c 	brls	8000424a <__avr32_udiv64+0x262>
80004236:	20 1c       	sub	r12,1
80004238:	1c 0b       	add	r11,lr
8000423a:	16 3e       	cp.w	lr,r11
8000423c:	e0 8b 00 07 	brhi	8000424a <__avr32_udiv64+0x262>
80004240:	16 31       	cp.w	r1,r11
80004242:	f7 bc 0b 01 	subhi	r12,1
80004246:	f7 de eb 0b 	addhi	r11,r11,lr
8000424a:	f4 08 09 46 	lsl	r6,r10,r8
8000424e:	02 1b       	sub	r11,r1
80004250:	f9 e3 11 0c 	or	r12,r12,r3<<0x10
80004254:	c3 ab       	rjmp	800040c8 <__avr32_udiv64+0xe0>
80004256:	12 3e       	cp.w	lr,r9
80004258:	f3 d8 eb 09 	addhi	r9,r9,r8
8000425c:	f7 bb 0b 01 	subhi	r11,1
80004260:	ca 8b       	rjmp	800041b0 <__avr32_udiv64+0x1c8>
80004262:	1c 3b       	cp.w	r11,lr
80004264:	f7 b6 0b 01 	subhi	r6,1
80004268:	fd d8 eb 0e 	addhi	lr,lr,r8
8000426c:	c9 0b       	rjmp	8000418c <__avr32_udiv64+0x1a4>
8000426e:	0c 3c       	cp.w	r12,r6
80004270:	f7 b3 0b 01 	subhi	r3,1
80004274:	ed de eb 06 	addhi	r6,r6,lr
80004278:	cd 1b       	rjmp	8000421a <__avr32_udiv64+0x232>

8000427a <memcpy>:
8000427a:	58 8a       	cp.w	r10,8
8000427c:	c2 f5       	brlt	800042da <memcpy+0x60>
8000427e:	f9 eb 10 09 	or	r9,r12,r11
80004282:	e2 19 00 03 	andl	r9,0x3,COH
80004286:	e0 81 00 97 	brne	800043b4 <memcpy+0x13a>
8000428a:	e0 4a 00 20 	cp.w	r10,32
8000428e:	c3 b4       	brge	80004304 <memcpy+0x8a>
80004290:	f4 08 14 02 	asr	r8,r10,0x2
80004294:	f0 09 11 08 	rsub	r9,r8,8
80004298:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000429c:	76 69       	ld.w	r9,r11[0x18]
8000429e:	99 69       	st.w	r12[0x18],r9
800042a0:	76 59       	ld.w	r9,r11[0x14]
800042a2:	99 59       	st.w	r12[0x14],r9
800042a4:	76 49       	ld.w	r9,r11[0x10]
800042a6:	99 49       	st.w	r12[0x10],r9
800042a8:	76 39       	ld.w	r9,r11[0xc]
800042aa:	99 39       	st.w	r12[0xc],r9
800042ac:	76 29       	ld.w	r9,r11[0x8]
800042ae:	99 29       	st.w	r12[0x8],r9
800042b0:	76 19       	ld.w	r9,r11[0x4]
800042b2:	99 19       	st.w	r12[0x4],r9
800042b4:	76 09       	ld.w	r9,r11[0x0]
800042b6:	99 09       	st.w	r12[0x0],r9
800042b8:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800042bc:	f8 08 00 28 	add	r8,r12,r8<<0x2
800042c0:	e0 1a 00 03 	andl	r10,0x3
800042c4:	f4 0a 11 04 	rsub	r10,r10,4
800042c8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800042cc:	17 a9       	ld.ub	r9,r11[0x2]
800042ce:	b0 a9       	st.b	r8[0x2],r9
800042d0:	17 99       	ld.ub	r9,r11[0x1]
800042d2:	b0 99       	st.b	r8[0x1],r9
800042d4:	17 89       	ld.ub	r9,r11[0x0]
800042d6:	b0 89       	st.b	r8[0x0],r9
800042d8:	5e fc       	retal	r12
800042da:	f4 0a 11 09 	rsub	r10,r10,9
800042de:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800042e2:	17 f9       	ld.ub	r9,r11[0x7]
800042e4:	b8 f9       	st.b	r12[0x7],r9
800042e6:	17 e9       	ld.ub	r9,r11[0x6]
800042e8:	b8 e9       	st.b	r12[0x6],r9
800042ea:	17 d9       	ld.ub	r9,r11[0x5]
800042ec:	b8 d9       	st.b	r12[0x5],r9
800042ee:	17 c9       	ld.ub	r9,r11[0x4]
800042f0:	b8 c9       	st.b	r12[0x4],r9
800042f2:	17 b9       	ld.ub	r9,r11[0x3]
800042f4:	b8 b9       	st.b	r12[0x3],r9
800042f6:	17 a9       	ld.ub	r9,r11[0x2]
800042f8:	b8 a9       	st.b	r12[0x2],r9
800042fa:	17 99       	ld.ub	r9,r11[0x1]
800042fc:	b8 99       	st.b	r12[0x1],r9
800042fe:	17 89       	ld.ub	r9,r11[0x0]
80004300:	b8 89       	st.b	r12[0x0],r9
80004302:	5e fc       	retal	r12
80004304:	eb cd 40 c0 	pushm	r6-r7,lr
80004308:	18 99       	mov	r9,r12
8000430a:	22 0a       	sub	r10,32
8000430c:	b7 07       	ld.d	r6,r11++
8000430e:	b3 26       	st.d	r9++,r6
80004310:	b7 07       	ld.d	r6,r11++
80004312:	b3 26       	st.d	r9++,r6
80004314:	b7 07       	ld.d	r6,r11++
80004316:	b3 26       	st.d	r9++,r6
80004318:	b7 07       	ld.d	r6,r11++
8000431a:	b3 26       	st.d	r9++,r6
8000431c:	22 0a       	sub	r10,32
8000431e:	cf 74       	brge	8000430c <memcpy+0x92>
80004320:	2f 0a       	sub	r10,-16
80004322:	c0 65       	brlt	8000432e <memcpy+0xb4>
80004324:	b7 07       	ld.d	r6,r11++
80004326:	b3 26       	st.d	r9++,r6
80004328:	b7 07       	ld.d	r6,r11++
8000432a:	b3 26       	st.d	r9++,r6
8000432c:	21 0a       	sub	r10,16
8000432e:	5c 3a       	neg	r10
80004330:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80004334:	d7 03       	nop
80004336:	d7 03       	nop
80004338:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000433c:	f3 66 00 0e 	st.b	r9[14],r6
80004340:	f7 36 00 0d 	ld.ub	r6,r11[13]
80004344:	f3 66 00 0d 	st.b	r9[13],r6
80004348:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000434c:	f3 66 00 0c 	st.b	r9[12],r6
80004350:	f7 36 00 0b 	ld.ub	r6,r11[11]
80004354:	f3 66 00 0b 	st.b	r9[11],r6
80004358:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000435c:	f3 66 00 0a 	st.b	r9[10],r6
80004360:	f7 36 00 09 	ld.ub	r6,r11[9]
80004364:	f3 66 00 09 	st.b	r9[9],r6
80004368:	f7 36 00 08 	ld.ub	r6,r11[8]
8000436c:	f3 66 00 08 	st.b	r9[8],r6
80004370:	f7 36 00 07 	ld.ub	r6,r11[7]
80004374:	f3 66 00 07 	st.b	r9[7],r6
80004378:	f7 36 00 06 	ld.ub	r6,r11[6]
8000437c:	f3 66 00 06 	st.b	r9[6],r6
80004380:	f7 36 00 05 	ld.ub	r6,r11[5]
80004384:	f3 66 00 05 	st.b	r9[5],r6
80004388:	f7 36 00 04 	ld.ub	r6,r11[4]
8000438c:	f3 66 00 04 	st.b	r9[4],r6
80004390:	f7 36 00 03 	ld.ub	r6,r11[3]
80004394:	f3 66 00 03 	st.b	r9[3],r6
80004398:	f7 36 00 02 	ld.ub	r6,r11[2]
8000439c:	f3 66 00 02 	st.b	r9[2],r6
800043a0:	f7 36 00 01 	ld.ub	r6,r11[1]
800043a4:	f3 66 00 01 	st.b	r9[1],r6
800043a8:	f7 36 00 00 	ld.ub	r6,r11[0]
800043ac:	f3 66 00 00 	st.b	r9[0],r6
800043b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800043b4:	20 1a       	sub	r10,1
800043b6:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800043ba:	f8 0a 0b 09 	st.b	r12[r10],r9
800043be:	cf b1       	brne	800043b4 <memcpy+0x13a>
800043c0:	5e fc       	retal	r12

800043c2 <memset>:
800043c2:	18 98       	mov	r8,r12
800043c4:	c0 38       	rjmp	800043ca <memset+0x8>
800043c6:	10 cb       	st.b	r8++,r11
800043c8:	20 1a       	sub	r10,1
800043ca:	58 0a       	cp.w	r10,0
800043cc:	cf d1       	brne	800043c6 <memset+0x4>
800043ce:	5e fc       	retal	r12

Disassembly of section .exception:

80004400 <_evba>:
80004400:	c0 08       	rjmp	80004400 <_evba>
	...

80004404 <_handle_TLB_Multiple_Hit>:
80004404:	c0 08       	rjmp	80004404 <_handle_TLB_Multiple_Hit>
	...

80004408 <_handle_Bus_Error_Data_Fetch>:
80004408:	c0 08       	rjmp	80004408 <_handle_Bus_Error_Data_Fetch>
	...

8000440c <_handle_Bus_Error_Instruction_Fetch>:
8000440c:	c0 08       	rjmp	8000440c <_handle_Bus_Error_Instruction_Fetch>
	...

80004410 <_handle_NMI>:
80004410:	c0 08       	rjmp	80004410 <_handle_NMI>
	...

80004414 <_handle_Instruction_Address>:
80004414:	c0 08       	rjmp	80004414 <_handle_Instruction_Address>
	...

80004418 <_handle_ITLB_Protection>:
80004418:	c0 08       	rjmp	80004418 <_handle_ITLB_Protection>
	...

8000441c <_handle_Breakpoint>:
8000441c:	c0 08       	rjmp	8000441c <_handle_Breakpoint>
	...

80004420 <_handle_Illegal_Opcode>:
80004420:	c0 08       	rjmp	80004420 <_handle_Illegal_Opcode>
	...

80004424 <_handle_Unimplemented_Instruction>:
80004424:	c0 08       	rjmp	80004424 <_handle_Unimplemented_Instruction>
	...

80004428 <_handle_Privilege_Violation>:
80004428:	c0 08       	rjmp	80004428 <_handle_Privilege_Violation>
	...

8000442c <_handle_Floating_Point>:
8000442c:	c0 08       	rjmp	8000442c <_handle_Floating_Point>
	...

80004430 <_handle_Coprocessor_Absent>:
80004430:	c0 08       	rjmp	80004430 <_handle_Coprocessor_Absent>
	...

80004434 <_handle_Data_Address_Read>:
80004434:	c0 08       	rjmp	80004434 <_handle_Data_Address_Read>
	...

80004438 <_handle_Data_Address_Write>:
80004438:	c0 08       	rjmp	80004438 <_handle_Data_Address_Write>
	...

8000443c <_handle_DTLB_Protection_Read>:
8000443c:	c0 08       	rjmp	8000443c <_handle_DTLB_Protection_Read>
	...

80004440 <_handle_DTLB_Protection_Write>:
80004440:	c0 08       	rjmp	80004440 <_handle_DTLB_Protection_Write>
	...

80004444 <_handle_DTLB_Modified>:
80004444:	c0 08       	rjmp	80004444 <_handle_DTLB_Modified>
	...

80004450 <_handle_ITLB_Miss>:
80004450:	c0 08       	rjmp	80004450 <_handle_ITLB_Miss>
	...

80004460 <_handle_DTLB_Miss_Read>:
80004460:	c0 08       	rjmp	80004460 <_handle_DTLB_Miss_Read>
	...

80004470 <_handle_DTLB_Miss_Write>:
80004470:	c0 08       	rjmp	80004470 <_handle_DTLB_Miss_Write>
	...

80004500 <_handle_Supervisor_Call>:
80004500:	c0 08       	rjmp	80004500 <_handle_Supervisor_Call>
80004502:	d7 03       	nop

80004504 <_int0>:
80004504:	30 0c       	mov	r12,0
80004506:	fe b0 ef 1f 	rcall	80002344 <_get_interrupt_handler>
8000450a:	58 0c       	cp.w	r12,0
8000450c:	f8 0f 17 10 	movne	pc,r12
80004510:	d6 03       	rete

80004512 <_int1>:
80004512:	30 1c       	mov	r12,1
80004514:	fe b0 ef 18 	rcall	80002344 <_get_interrupt_handler>
80004518:	58 0c       	cp.w	r12,0
8000451a:	f8 0f 17 10 	movne	pc,r12
8000451e:	d6 03       	rete

80004520 <_int2>:
80004520:	30 2c       	mov	r12,2
80004522:	fe b0 ef 11 	rcall	80002344 <_get_interrupt_handler>
80004526:	58 0c       	cp.w	r12,0
80004528:	f8 0f 17 10 	movne	pc,r12
8000452c:	d6 03       	rete

8000452e <_int3>:
8000452e:	30 3c       	mov	r12,3
80004530:	fe b0 ef 0a 	rcall	80002344 <_get_interrupt_handler>
80004534:	58 0c       	cp.w	r12,0
80004536:	f8 0f 17 10 	movne	pc,r12
8000453a:	d6 03       	rete
8000453c:	d7 03       	nop
8000453e:	d7 03       	nop
80004540:	d7 03       	nop
80004542:	d7 03       	nop
80004544:	d7 03       	nop
80004546:	d7 03       	nop
80004548:	d7 03       	nop
8000454a:	d7 03       	nop
8000454c:	d7 03       	nop
8000454e:	d7 03       	nop
80004550:	d7 03       	nop
80004552:	d7 03       	nop
80004554:	d7 03       	nop
80004556:	d7 03       	nop
80004558:	d7 03       	nop
8000455a:	d7 03       	nop
8000455c:	d7 03       	nop
8000455e:	d7 03       	nop
80004560:	d7 03       	nop
80004562:	d7 03       	nop
80004564:	d7 03       	nop
80004566:	d7 03       	nop
80004568:	d7 03       	nop
8000456a:	d7 03       	nop
8000456c:	d7 03       	nop
8000456e:	d7 03       	nop
80004570:	d7 03       	nop
80004572:	d7 03       	nop
80004574:	d7 03       	nop
80004576:	d7 03       	nop
80004578:	d7 03       	nop
8000457a:	d7 03       	nop
8000457c:	d7 03       	nop
8000457e:	d7 03       	nop
80004580:	d7 03       	nop
80004582:	d7 03       	nop
80004584:	d7 03       	nop
80004586:	d7 03       	nop
80004588:	d7 03       	nop
8000458a:	d7 03       	nop
8000458c:	d7 03       	nop
8000458e:	d7 03       	nop
80004590:	d7 03       	nop
80004592:	d7 03       	nop
80004594:	d7 03       	nop
80004596:	d7 03       	nop
80004598:	d7 03       	nop
8000459a:	d7 03       	nop
8000459c:	d7 03       	nop
8000459e:	d7 03       	nop
800045a0:	d7 03       	nop
800045a2:	d7 03       	nop
800045a4:	d7 03       	nop
800045a6:	d7 03       	nop
800045a8:	d7 03       	nop
800045aa:	d7 03       	nop
800045ac:	d7 03       	nop
800045ae:	d7 03       	nop
800045b0:	d7 03       	nop
800045b2:	d7 03       	nop
800045b4:	d7 03       	nop
800045b6:	d7 03       	nop
800045b8:	d7 03       	nop
800045ba:	d7 03       	nop
800045bc:	d7 03       	nop
800045be:	d7 03       	nop
800045c0:	d7 03       	nop
800045c2:	d7 03       	nop
800045c4:	d7 03       	nop
800045c6:	d7 03       	nop
800045c8:	d7 03       	nop
800045ca:	d7 03       	nop
800045cc:	d7 03       	nop
800045ce:	d7 03       	nop
800045d0:	d7 03       	nop
800045d2:	d7 03       	nop
800045d4:	d7 03       	nop
800045d6:	d7 03       	nop
800045d8:	d7 03       	nop
800045da:	d7 03       	nop
800045dc:	d7 03       	nop
800045de:	d7 03       	nop
800045e0:	d7 03       	nop
800045e2:	d7 03       	nop
800045e4:	d7 03       	nop
800045e6:	d7 03       	nop
800045e8:	d7 03       	nop
800045ea:	d7 03       	nop
800045ec:	d7 03       	nop
800045ee:	d7 03       	nop
800045f0:	d7 03       	nop
800045f2:	d7 03       	nop
800045f4:	d7 03       	nop
800045f6:	d7 03       	nop
800045f8:	d7 03       	nop
800045fa:	d7 03       	nop
800045fc:	d7 03       	nop
800045fe:	d7 03       	nop
